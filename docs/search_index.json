[
["index.html", "Notes for Case Studies in Health Big Data Preface", " Notes for Case Studies in Health Big Data Nicholas Henderson 2022-01-11 Preface This contains some of the course notes for Biostatistics 629. "],
["mixed-models.html", "Chapter 1 Mixed Models for Longitudinal Data Analysis 1.1 Methods for Analyzing Longitudinal Data 1.2 Mixed Models for Continuous Outcomes 1.3 Advantages of using random effects 1.4 Generalized linear mixed models (GLMMs) 1.5 Fitting Linear Mixed Models (LMMs) and Generalized Linear Mixed models (GLMMs) in R", " Chapter 1 Mixed Models for Longitudinal Data Analysis 1.1 Methods for Analyzing Longitudinal Data Longitudinal data refers to data that: Has multiple individuals/subjects. Each individual has multiple observations that were taken across time. We will denote the outcomes of interest with \\(Y_{ij}\\). \\(Y_{ij}\\) - outcome for individual \\(i\\) at time \\(t_{ij}\\). The \\(i^{th}\\) individual has \\(n_{i}\\) observations: \\(Y_{i1}, \\ldots, Y_{in_{i}}\\). There will be \\(m\\) individuals in the study (so \\(1 \\leq i \\leq m\\)). \\(\\mathbf{x}_{ij} = (x_{ij1}, \\ldots, x_{ijp})\\) is the vector of covariates for individual \\(i\\) at time \\(t_{ij}\\). Note: The data that you analyze for this project could be “asynchronous”, meaning that the outcomes \\(Y_{ij}\\) and the covariates are not exactly matched in time. For example, on a given day, you may observe \\(Y_{ij}\\) at 9:00, 10:00, and 11:00, but observe the covariate of interest at 9:17, 9:53, and 11:08. We will probably discuss some ways of processing asynchronous longitudinal data later in the class. The above figure shows an example of outcomes from a longitudinal study (the sleepstudy data in the lme4 package). In the sleepstudy data: The time points of observation \\(t_{ij}\\) are the same for each individual \\(i\\). So, we can say \\(t_{ij} = t_{j}\\) for all \\(i\\). The outcome \\(Y_{ij}\\) is the reaction time for the \\(i^{th}\\) individual at time point \\(t_{j}\\). The 10 time points are \\((t_{1}, \\ldots, t_{10}) = (0, 1, \\ldots, 9)\\). Most of the well-known regression-based methods for analyzing longitudinal data can be classified (see Diggle et al. (2013)) into one of the three following categories: Random effects/mixed models, Marginal models, Transition models Random effects/Mixed Models “Random effects” are added to the regression model describing the outcomes for each individual. These “random regression coefficients” are viewed as a sample from some distribution. Marginal models Regression coefficients have a “population average” interpretation. Only mean of \\(Y_{ij}\\) and correlation structure of \\((Y_{i1}, \\ldots, Y_{in_{i}})\\) are modeled. Generalized estimating equations (GEEs) are often used for estimating model parameters. Transition models Uses a probability model for the distribution of \\(Y_{ij}\\) given the value of the outcome at the previous time point \\(Y_{ij-1}\\). 1.2 Mixed Models for Continuous Outcomes If each \\(Y_{ij}\\) is a continuous outcome and we were to build a regression model without any random effects, we might assume something like: \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + e_{ij} \\tag{1.1} \\end{equation}\\] \\(\\mathbf{x}_{ij} = (x_{ij1}, \\ldots, x_{ijp})\\) is the vector of covariates for individual \\(i\\) at time \\(t_{ij}\\). The vector \\(\\mathbf{x}_{ij}\\) could contain individual information such as smoking status or age. \\(\\mathbf{x}_{ij}\\) could also contain some of the actual time points: \\(t_{ij}, t_{ij-1}, ...\\) or transformations of these time points. The regression model (1.1) assumes the same mean function \\(\\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta}\\) holds for all individuals that have the same value of \\(\\mathbf{x}_{ij}\\). It is often reasonable to assume that the regression coefficients vary across individuals. This can often better account for heterogeneity across individuals. The figure below shows 3 different regression lines from the sleepstudy data. Each regression line was estimated using only data from one individual. Figure 1.1: Separately estimated regression lines for 3 subjects in the sleepstudy data. Figure 1.1 suggests there is some heterogeneity in the relationship between study day and response time across individuals. The response time of Subject 309 changes very little over time. For Subject 308, there is a more clear positive association between response time and day of study. For the sleepstudy data, a linear regression for reaction time vs. study day which assumes that Expected response time is a linear function of study day, All individuals have the same regression coefficients, would have the form: \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\beta_{1} t_{j} + e_{ij} \\end{equation}\\] If we allowed each individual to have his/her own intercept and slope, we could instead consider the following model \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\beta_{1} t_{j} + u_{i0} + u_{i1}t_{j} + e_{ij} \\tag{1.2} \\end{equation}\\] \\(\\beta_{0} + u_{i0}\\) - intercept for individual \\(i\\). \\(\\beta_{1} + u_{i1}\\) - slope for individual \\(i\\). If we assume \\((u_{i0}, u_{i1})\\) are sampled from some distribution, \\(u_{i0}\\) and \\(u_{i1}\\) are referred to as random effects. Typically, it is assumed that \\((u_{i0}, u_{i1})\\) are sampled from a multivariate normal distribution with mean zero: \\[\\begin{equation} (u_{i0}, u_{i1}) \\sim \\textrm{Normal}( \\mathbf{0}, \\boldsymbol{\\Sigma}_{\\tau} ) \\end{equation}\\] Model (1.2) is called a mixed model because it contains both fixed effects \\((\\beta_{0}, \\beta_{1})\\) and random effects \\((u_{i0}, u_{i1})\\). More generally, a linear mixed model (LMM) for longitudinal data will have the form: \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} + e_{ij} \\tag{1.3} \\end{equation}\\] \\(\\boldsymbol{\\beta}\\) - vector of fixed effects \\(\\mathbf{u}_{i}\\) - vector of random effects If we stack the responses into a long vector \\(\\mathbf{Y}\\) and random effects into a long vector \\(\\mathbf{u}\\) \\(\\mathbf{Y} = (Y_{11}, Y_{12}, ...., Y_{mn_{m}})\\) - this vector has length \\(\\sum_{k=1}^{m} n_{k}\\) \\(\\mathbf{u} = (u_{10}, u_{11}, ...., u_{mq})\\) - this vector has length \\(m \\times (q + 1)\\). Then, we can write the general form (1.3) of the LMM as \\[\\begin{equation} \\mathbf{Y} = \\mathbf{X}\\tilde{\\boldsymbol{\\beta}} + \\mathbf{Z}\\mathbf{u} + \\mathbf{e} \\end{equation}\\] \\(i^{th}\\) row of \\(\\mathbf{X}\\) is \\((1, \\mathbf{x}_{ij}^{T})\\). \\(i^{th}\\) row of \\(\\mathbf{Z}\\) is \\(\\mathbf{z}_{ij}^{T}\\). \\(\\tilde{\\boldsymbol{\\beta}} = (1, \\boldsymbol{\\beta})\\). Constructing an LMM can be thought of as choosing the desired “\\(\\mathbf{X}\\)” and “\\(\\mathbf{Z}\\)” matrices. 1.3 Advantages of using random effects 1.3.1 Within-subject correlation Using an LMM automatically accounts for the “within-subject” correlation. That is, the correlation between two observations from the same individual. This correlation arises because observations on the same individual “share” common random effects. The correlation between the \\(j^{th}\\) and \\(k^{th}\\) observation from individual \\(i\\) is \\[\\begin{equation} \\textrm{Corr}(Y_{ij}, Y_{ik}) = \\frac{ \\mathbf{z}_{ij}^{T}\\boldsymbol{\\Sigma}_{\\tau}\\mathbf{z}_{ik} }{ \\sqrt{\\sigma^{2} + \\mathbf{z}_{ij}^{T}\\boldsymbol{\\Sigma}_{\\tau}\\mathbf{z}_{ij}}\\sqrt{\\sigma^{2} + \\mathbf{z}_{ik}^{T}\\boldsymbol{\\Sigma}_{\\tau}\\mathbf{z}_{ik}}} \\end{equation}\\] When using only a random intercept, the correlation between \\(Y_{ij}\\) and \\(Y_{ik}\\) is \\[\\begin{equation} \\textrm{Corr}(Y_{ij}, Y_{ik}) = \\frac{ \\sigma_{u}^{2} }{ \\sigma^{2} + \\sigma_{u}^{2} } \\end{equation}\\] In this case, \\(\\mathbf{z}_{ij} = 1\\) and \\(u_{i} \\sim \\textrm{Normal}(0, \\sigma_{u}^{2})\\) \\(\\sigma^{2}\\) is the variance of the residual term \\(e_{ij}\\) For longitudinal data, one criticism of the random intercept model is that the within-subject correlation does not vary across time. 1.3.2 Inference about Heterogeneity - Variance of Random Effects One of the goals of the data analysis may be to characterize the heterogeneity in the relationship between the outcome and some of the covariates across individuals. Looking at the estimates of the variance of the random effects is one way of addressing this goal. An estimate of \\(\\textrm{Var}( u_{ih} )\\) “substantially greater than zero” is an indication that there is variability in the regression coefficient corresponding to \\(u_{ih}\\) across individuals. For example, with the random intercept and slope model for the sleepstudy data \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\beta_{1}t_{j} + u_{i0} + u_{i1}t_{j} + e_{ij} \\end{equation}\\] If \\(\\textrm{Var}( u_{i1} )\\) is “large”, this implies that the response to additional days of sleep deprivation varies considerably across individuals. The response time of some individuals is not impacted much by additional days of little sleep. Some individuals respond strongly to additional days of little sleep. 1.3.3 Best Linear Unbiased Prediction You may want to estimate or “predict” the mean function/trajectory of a given individual. This means you want to estimate/predict the following quantity: \\[\\begin{equation} \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} \\end{equation}\\] The “Best Linear Unbiased Predictor” (BLUP) of this is \\[\\begin{equation} \\textrm{BLUP}(\\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i}) = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}E(\\mathbf{u}_{i}|Y_{i1}, \\ldots, Y_{in_{i}}) \\end{equation}\\] I would think of the values of \\(\\textrm{BLUP}(\\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i})\\) (for different values of \\(j\\)) as an estimate of the “true trajectory” (i.e., the true mean) of the \\(i^{th}\\) individual. The observed longitudinal outcomes from individual \\(i\\) are a “noisy estimate” of that individual’s true trajectory. The BLUPs are more stable “shrinkage” estimates of the trajectory of individual \\(i\\). These are called shrinkage estimates because often shrinks the estimate that would be obtained using only data from individual \\(i\\) towards the “overall” estimate \\(\\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta}\\). For example, if we had the intercept-only model \\(Y_{ij} = \\beta_{0} + u_{i} + e_{ij}\\), the value of the BLUPs is \\[\\begin{equation} \\textrm{BLUP}(\\beta_{0} + u_{i}) = \\frac{n_{i}\\sigma_{u}^{2}}{\\sigma^{2} + n_{i}\\sigma_{u}^{2} }\\bar{Y}_{i.} + \\Big(1 - \\frac{n_{i}\\sigma_{u}^{2}}{\\sigma^{2} + n_{i}\\sigma_{u}^{2} }\\Big)\\bar{Y}_{..} \\end{equation}\\] \\(\\bar{Y}_{i.}\\) is the sample mean from individual-\\(i\\) data \\(\\bar{Y}_{i.}\\) would be the estimate of the intercept if we only looked at data from the \\(i^{th}\\) individual. \\(\\bar{Y}_{..}\\) - overall mean \\(\\bar{Y}_{..}\\) would be the estimate of the intercept if we ignored variation in intercepts across individuals. You can also think of \\(\\textrm{BLUP}(\\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i})\\) as a prediction of what the observed trajectory for individual \\(i\\) would be if that individual were in a future study under the same conditions. Say \\(Y_{i1}&#39;, \\ldots, Y_{in_{i}}&#39;\\) are the observations for individual \\(i\\) in a future study. The outcomes in the future study are determined by \\[\\begin{equation} Y_{ij}&#39; = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} + e_{ij}&#39; \\end{equation}\\] The expectation of \\(Y_{ij}&#39;\\) given the observed data in our longitudinal study is \\[\\begin{eqnarray} E(Y_{ij}&#39;|Y_{i1}, \\ldots, Y_{in_{i}}) &amp;=&amp; \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}E(\\mathbf{u}_{i}|Y_{i1}, \\ldots, Y_{in_{i}}) \\nonumber \\\\ &amp;=&amp; \\textrm{BLUP}(\\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i}) \\nonumber \\end{eqnarray}\\] 1.4 Generalized linear mixed models (GLMMs) Generalized linear models (GLMs) are used to handle “non-continuous” data that can’t be reasonably modeled with a Gaussian distribution. The most common scenarios where you would use GLMs in practice are binary, count, and multinomial outcomes. With a generalized linear mixed model (GLMM), you assume that a GLM holds conditional on the value of the random effects. 1.4.1 GLMMs with Binary Outcomes Under the GLM framework, the usual approach for handling binary outcomes is logistic regression. The assumptions underying logistic regression are: The outcomes are independent Each outcome follows a Bernoulli distribution. The log-odds parameter is assumed to be a linear combination of the covariates. With the GLMM version of logistic regression, we will make almost the same assumptions as the regular GLM version of logistic regression. The main difference is that each assumption in the GLMM will be conditional on the values of the random effects. To be specific, for longitudinal binary outcomes \\(Y_{ij}\\), the GLMM version of logistic regression assumes the following: Conditional on the vector of random effects \\(\\mathbf{u}_{i}\\) \\[\\begin{equation} Y_{i1}, \\ldots, Y_{in_{i}}|\\mathbf{u}_{i} \\textrm{ are independent } \\end{equation}\\] Conditional on \\(\\mathbf{u}_{i}\\), each \\(Y_{ij}\\) has a Bernoulli distribution \\[\\begin{equation} Y_{ij}|\\mathbf{u}_{i} \\sim \\textrm{Bernoulli}\\big\\{ p_{ij}(\\mathbf{u}_{i}) \\big\\} \\end{equation}\\] so that \\(p_{ij}( \\mathbf{u}_{i} ) = P(Y_{ij} = 1| \\mathbf{u}_{i})\\). The “conditional” log-odds term \\(\\log\\{ p_{ij}(\\mathbf{u}_{i})/[1 - p_{ij}(\\mathbf{u}_{i})] \\}\\) is a linear combination of the covariates and the random effects vector \\(\\mathbf{u}_{i}\\): \\[\\begin{equation} \\textrm{logit}\\{ p_{ij}(\\mathbf{u}_{i}) \\} = \\log\\Big( \\frac{ p_{ij}(\\mathbf{u}_{i})}{ 1 - p_{ij}(\\mathbf{u}_{i}) } \\Big) = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} \\end{equation}\\] As with a linear mixed model, we assume that the random-effects vector \\(\\mathbf{u}_{i}\\) has a multivariate normal distribution with mean zero and covariance matrix \\(\\boldsymbol{\\Sigma}_{\\tau}\\) \\[\\begin{equation} \\mathbf{u}_{i} \\sim \\textrm{Normal}( \\mathbf{0}, \\boldsymbol{\\Sigma}_{\\tau}) \\end{equation}\\] 1.4.2 GLMMs with Count Outcomes For count outcomes, responses are typically assumed to follow a Poisson distribution and sometimes a negative binomial distribution - conditional on the values of the random effects. For the Poisson model, we assume \\(Y_{ij}|\\mathbf{u}_{i} \\sim \\textrm{Poisson}\\{ \\mu_{ij}( \\mathbf{u}_{i} ) \\}\\), \\[\\begin{equation} E(Y_{ij}| \\mathbf{u}_{i}) = \\mu_{ij}(\\mathbf{u}_{i}) \\qquad \\textrm{Var}( Y_{ij}| \\mathbf{u}_{i} ) = \\mu_{ij}(\\mathbf{u}_{i}) \\end{equation}\\] One common problem with the Poisson distribution is overdispersion (i.e., variance is greater than the mean). The variance of the Poisson equals the mean. While the marginal variance will not equal the mean in a GLMM, requiring the conditional means and variances to be equal could lead to a poor fit. For the negative binomial model, we assume \\(Y_{ij}|\\mathbf{u}_{i} \\sim \\textrm{NB}\\{ \\mu_{ij}( \\mathbf{u}_{i}) , \\phi \\}\\), \\[\\begin{equation} E(Y_{ij}| \\mathbf{u}_{i}) = \\mu_{ij}(\\mathbf{u}_{i}) \\qquad \\textrm{Var}( Y_{ij}| \\mathbf{u}_{i} ) = \\mu_{ij}(\\mathbf{u}_{i}) + \\phi\\mu_{ij}^{2}(\\mathbf{u}_{i}) \\end{equation}\\] \\(\\phi\\) is often referred to as the overdispersion parameter. With a GLMM model for count data, it is typical to model the log of the conditional mean \\(\\mu_{ij}(\\mathbf{u}_{i})\\) with a linear regression: \\[\\begin{equation} \\log\\{ \\mu_{ij}(\\mathbf{u}_{i}) \\} = \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} \\end{equation}\\] Again, for the Poisson GLMM, the usual assumption for the random effects is that \\[\\begin{equation} \\mathbf{u}_{i} \\sim \\textrm{Normal}( \\mathbf{0}, \\boldsymbol{\\Sigma}_{\\tau}) \\end{equation}\\] 1.5 Fitting Linear Mixed Models (LMMs) and Generalized Linear Mixed models (GLMMs) in R The lme4 package is probably the most general package for fitting LMMs and GLMMs. library(lme4) With Python, you can use the mixedlm function from the statmodels module to fit linear mixed models. 1.5.1 Fitting LMMs with the sleepstudy data To start off, let’s use the sleepstudy longitudinal data in lme4 and look at the data from the first two individuals in this data. data(sleepstudy) dim(sleepstudy) # 18 individuals, each with 10 observations ## [1] 180 3 sleepstudy[1:20,] # Data from the subjects with ids: 308 and 309 ## Reaction Days Subject ## 1 249.5600 0 308 ## 2 258.7047 1 308 ## 3 250.8006 2 308 ## 4 321.4398 3 308 ## 5 356.8519 4 308 ## 6 414.6901 5 308 ## 7 382.2038 6 308 ## 8 290.1486 7 308 ## 9 430.5853 8 308 ## 10 466.3535 9 308 ## 11 222.7339 0 309 ## 12 205.2658 1 309 ## 13 202.9778 2 309 ## 14 204.7070 3 309 ## 15 207.7161 4 309 ## 16 215.9618 5 309 ## 17 213.6303 6 309 ## 18 217.7272 7 309 ## 19 224.2957 8 309 ## 20 237.3142 9 309 The sleepstudy data is an example of longitudinal data stored in long format (as opposed to “wide” format). In long format, each row of the dataset corresponds to an observation from one individual at one time point. The lmer function in lme4 fits linear mixed models. This has many of the same features as the lm function in R. To fit an LMM with lmer, the main thing to do is to specify the “X” part of the model (i.e., the fixed effects) and the “Z” part of the model (i.e., the random effects). The “X” part of the model is done using the exact same “formula notation” used in the lm function. The “Z” part of the model is done using the following type of syntax: (formula | group_var) group_var is the “grouping variable” used for the random effects For longitudinal data, this would be the variable which identifies each individual. 1.5.1.1 LMM with a single, random intercept for each subject Let’s fit an LMM where there is a fixed slope for time and only a random intercept for each Subject \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\beta_{1}t_{j} + u_{i} + e_{ij} \\tag{1.4} \\end{equation}\\] For the “X” part of this model, we use Reaction ~ Days. This gives us a fixed intercept and a fixed slope for the Days variable. For the “Z” part of this model, we just add (1|Subject). This says that there is only a random intercept within the grouping variable Subject. Putting these two together, we can fit the LMM (1.4) using the following code: lmm.sleep.intercept &lt;- lmer(Reaction ~ Days + (1|Subject), data = sleepstudy) You can always use the model.matrix method on the fitted lmer object to check that the “X” and “Z” matrices correspond to the model you want. Let’s look at the first 5 rows of the “X” matrix from lmm.sleep.intercept x.mat &lt;- model.matrix(lmm.sleep.intercept) ## This design matrix should have an intercept column ## and a column which stores the &quot;Days&quot; variable x.mat[1:5,] ## (Intercept) Days ## 1 1 0 ## 2 1 1 ## 3 1 2 ## 4 1 3 ## 5 1 4 Let’s look at the first 20 rows of the “Z” matrix from lmm.intercept ## Use argument type = &quot;random&quot; to get random-effects design matrix z.mat &lt;- model.matrix(lmm.sleep.intercept, type=&quot;random&quot;) z.mat[1:20,] # The . values in zmat correspond to zeros ## 20 x 18 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 18 column names &#39;308&#39;, &#39;309&#39;, &#39;310&#39; ... ]] ## ## 1 1 . . . . . . . . . . . . . . . . . ## 2 1 . . . . . . . . . . . . . . . . . ## 3 1 . . . . . . . . . . . . . . . . . ## 4 1 . . . . . . . . . . . . . . . . . ## 5 1 . . . . . . . . . . . . . . . . . ## 6 1 . . . . . . . . . . . . . . . . . ## 7 1 . . . . . . . . . . . . . . . . . ## 8 1 . . . . . . . . . . . . . . . . . ## 9 1 . . . . . . . . . . . . . . . . . ## 10 1 . . . . . . . . . . . . . . . . . ## 11 . 1 . . . . . . . . . . . . . . . . ## 12 . 1 . . . . . . . . . . . . . . . . ## 13 . 1 . . . . . . . . . . . . . . . . ## 14 . 1 . . . . . . . . . . . . . . . . ## 15 . 1 . . . . . . . . . . . . . . . . ## 16 . 1 . . . . . . . . . . . . . . . . ## 17 . 1 . . . . . . . . . . . . . . . . ## 18 . 1 . . . . . . . . . . . . . . . . ## 19 . 1 . . . . . . . . . . . . . . . . ## 20 . 1 . . . . . . . . . . . . . . . . The . values in z.mat are just zeros. Notice that each Subject has its own “intercept” column. This what we want - each Subject has its own intercept. Let’s look at the estimated parameters from the LMM with random intercepts using summary summary(lmm.sleep.intercept) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: Reaction ~ Days + (1 | Subject) ## Data: sleepstudy ## ## REML criterion at convergence: 1786.5 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.2257 -0.5529 0.0109 0.5188 4.2506 ## ## Random effects: ## Groups Name Variance Std.Dev. ## Subject (Intercept) 1378.2 37.12 ## Residual 960.5 30.99 ## Number of obs: 180, groups: Subject, 18 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 251.4051 9.7467 25.79 ## Days 10.4673 0.8042 13.02 ## ## Correlation of Fixed Effects: ## (Intr) ## Days -0.371 The estimated fixed-effects intercept is \\(\\hat{\\beta}_{0} = 251.4\\), and the estimated fixed-effects slope is \\(\\hat{\\beta}_{1} = 10.5\\). The estimated variance of the random intercept is \\(\\hat{\\tau}^{2} = 1378.2\\) (standard deviation is \\(\\hat{\\tau} = 37.1\\)). i.e., it is estimated that \\(u_{i} \\sim \\textrm{Normal}(0, 1378.2)\\). 1.5.1.2 LMM with both a random intercept and slope for each subject Now, let’s fit an LMM where there is a fixed slope for time and both a random intercept and slope for each Subject \\[\\begin{equation} Y_{ij} = \\beta_{0} + \\beta_{1}t_{j} + u_{i0} + u_{i1}t_{j} + e_{ij} \\tag{1.5} \\end{equation}\\] This is done with lmer using the following code: lmm.sleep.slope &lt;- lmer(Reaction ~ Days + (Days|Subject), data = sleepstudy) Again, let’s check the “X” and “Z” matrices from lmm.sleep.slope to double-check that everything makes sense x.mat2 &lt;- model.matrix(lmm.sleep.slope) ## This design matrix should be the same as that from lmm.sleep.intercept x.mat2[1:5,] ## (Intercept) Days ## 1 1 0 ## 2 1 1 ## 3 1 2 ## 4 1 3 ## 5 1 4 First 20 rows of the “Z” matrix from lmm.sleep.slope: ## Use argument type = &quot;random&quot; to get random-effects design matrix z.mat2 &lt;- model.matrix(lmm.sleep.slope, type=&quot;random&quot;) z.mat2[1:20,] # The . values in zmat2 correspond to zeros ## 20 x 36 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 36 column names &#39;308&#39;, &#39;308&#39;, &#39;309&#39; ... ]] ## ## 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 2 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 3 1 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 4 1 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 5 1 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 6 1 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 7 1 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 8 1 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 9 1 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 10 1 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 11 . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 12 . . 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 13 . . 1 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 14 . . 1 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 15 . . 1 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 16 . . 1 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 17 . . 1 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 18 . . 1 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 19 . . 1 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ## 20 . . 1 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Note that the two columns for each Subject in z.mat2 are of the form \\((1, t_{j})\\), which is what we want. Let’s look at the estimated parameters from lmm.sleep.slope summary(lmm.sleep.slope) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: Reaction ~ Days + (Days | Subject) ## Data: sleepstudy ## ## REML criterion at convergence: 1743.6 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.9536 -0.4634 0.0231 0.4634 5.1793 ## ## Random effects: ## Groups Name Variance Std.Dev. Corr ## Subject (Intercept) 612.10 24.741 ## Days 35.07 5.922 0.07 ## Residual 654.94 25.592 ## Number of obs: 180, groups: Subject, 18 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 251.405 6.825 36.838 ## Days 10.467 1.546 6.771 ## ## Correlation of Fixed Effects: ## (Intr) ## Days -0.138 The estimated fixed-effects coefficients are \\(\\hat{\\beta}_{0} = 251.4\\), and \\(\\hat{\\beta}_{1} = 10.5\\) respectively. The estimated standard deviation and correlation of the random effects are Estimated standard deviation of \\(u_{i0}\\) is \\(24.7\\). Estimated standard deviation of \\(u_{i1}\\) is \\(5.9\\). Estimated correlation between \\(u_{i0}\\) and \\(u_{i1}\\) is \\(0.07\\). Rather than always printing out the entire summary, you can directly extract the estimates of the fixed effects with coef( summary(lmm.sleep.slope) ) ## Estimate Std. Error t value ## (Intercept) 251.40510 6.824597 36.838090 ## Days 10.46729 1.545790 6.771481 To directly extract the estimates of the variance (or standard deviation) of the random effects, you can use: VarCorr( lmm.sleep.slope ) ## Groups Name Std.Dev. Corr ## Subject (Intercept) 24.7407 ## Days 5.9221 0.066 ## Residual 25.5918 Interpreting the estimated variance of the random effects One way I like to think about the magnitude of the variance components is to look at the 5th and 95th percentiles of the random effects distribution. For example, if you only have a random intercept term, then roughly \\(90\\%\\) of individuals will have an intercept that falls in the interval \\([\\hat{\\beta}_{0} - 1.64\\hat{\\sigma}_{u0}, \\hat{\\beta}_{0} + 1.64\\hat{\\sigma}_{u0}]\\). If you have a random slope term, then roughly \\(90\\%\\) of individuals will have an intercept that falls in the interval \\([\\hat{\\beta}_{1} - 1.64\\hat{\\sigma}_{u1}, \\hat{\\beta}_{1} + 1.64\\hat{\\sigma}_{u1}]\\). Another idea for helping to interpret the magnitude of the random effects is to plot many random trajectories for specific choices of the covariate vector \\(\\mathbf{x}_{i}\\) (if the \\(\\mathbf{x}_{i}\\) vary across individuals). For example, in the sleepstudy data, you could plot \\(\\hat{\\beta}_{0} + u_{i0} + \\hat{\\beta}_{1}t_{j} + u_{i1}t_{j}\\) where the pairs \\((u_{i0}, u_{i1})\\) are generated from the estimated joint Normal distribution. Sigma.hat &lt;- VarCorr( lmm.sleep.slope )$Subject # This is the random-effects # covariance matrix ndraws &lt;- 100 Sigma.hat.sqrt &lt;- chol(Sigma.hat) beta.hat &lt;- coef( summary(lmm.sleep.slope) )[,1] # estimated fixed effects print(beta.hat) ## (Intercept) Days ## 251.40510 10.46729 plot(sleepstudy$Days, sleepstudy$Reaction, type=&quot;n&quot;, xlab=&quot;Days&quot;, ylab=&quot;Response&quot;, las=1, main=&quot;sleepstudy: Variation in subject-specific trajectories&quot;) for(k in 1:ndraws) { uvec.draw &lt;- Sigma.hat.sqrt%*%rnorm(2) # draw random (ui0, ui1) pair trajectory &lt;- beta.hat[1] + uvec.draw[1] + (0:9)*(beta.hat[2] + uvec.draw[2]) lines(0:9, trajectory) } Figure 1.2: Random trajectories for sleepstudy data using the estimated intercept and slope random-effects variances. 1.5.1.3 Extracting BLUPs in lme4 To get the “BLUPs” the intercepts and slopes \\(\\textrm{BLUP}(u_{i0})\\) and \\(\\textrm{BLUP}(u_{i1})\\), use ranef blups.slope &lt;- ranef( lmm.sleep.slope ) To plot these, use dotplot (you will need to load the lattice package first) library(lattice) dotplot(blups.slope) ## $Subject ## This plots subjects sorted by individual-specific estimates of intercepts To extract the “predicted” random effects into a DataFrame use ranef.df &lt;- as.data.frame( blups.slope) head(ranef.df) ## grpvar term grp condval condsd ## 1 Subject (Intercept) 308 2.258551 12.07086 ## 2 Subject (Intercept) 309 -40.398738 12.07086 ## 3 Subject (Intercept) 310 -38.960409 12.07086 ## 4 Subject (Intercept) 330 23.690620 12.07086 ## 5 Subject (Intercept) 331 22.260313 12.07086 ## 6 Subject (Intercept) 332 9.039568 12.07086 This returns a data frame of the BLUPs for each random effect along with a “standard error” for each BLUP. What we discussed earlier in Section 1.3, were the BLUPs for \\(\\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}\\mathbf{u}_{i}\\) not just the individual components of \\(\\mathbf{u}_{i}\\). For this random intercept and slope model, this is \\(\\textrm{BLUP}(\\beta_{0} + \\beta_{1}t_{j} + u_{i0} + u_{i1}t_{j})\\) These are obtained by using the fitted method blup.full &lt;- fitted( lmm.sleep.slope ) # Should be a vector of length 180 If we plot \\(\\textrm{BLUP}(\\beta_{0} + \\beta_{1}t_{j} + u_{i0} + u_{i1}t_{j})\\) as a function of time for all individuals, it will look like the following: library(ggplot2) # First add the BLUPs to the sleepstudy data as a separate variable sleepstudy$blups &lt;- blup.full # Now plot BLUPs vs. study data for each subject ggplot(sleepstudy, aes(x=Days, y=blups, group=Subject)) + geom_line(aes(color=Subject)) + labs(title = &quot;BLUPs in Random Intercept + Random Slope Model&quot;, y = &quot;Reaction Time&quot;) 1.5.2 Fitting Binary GLMMs using the Ohio data To use the ohio data, we will first load the geepack R package: library(geepack) This dataset has 2148 observations from 537 individuals data(ohio) head(ohio, 12) # look at first 12 rows of ohio ## resp id age smoke ## 1 0 0 -2 0 ## 2 0 0 -1 0 ## 3 0 0 0 0 ## 4 0 0 1 0 ## 5 0 1 -2 0 ## 6 0 1 -1 0 ## 7 0 1 0 0 ## 8 0 1 1 0 ## 9 0 2 -2 0 ## 10 0 2 -1 0 ## 11 0 2 0 0 ## 12 0 2 1 0 The outcome of interest in ohio is “wheezing status”: 1 - yes, 0 - no. The resp variable contains wheezing status. The id variable contains the unique identifier for each individual. The age in the ohio dataset is the time variable. The age variable is recorded as: (age in years - 9). Each individual starts the study at 7 years of age. The smoke variable is an indicator of maternal smoking at the starting year of the study. In lme4, fitting a GLMM with binary responses can be done with the glmer function. The glmer function has the following syntax: glmer(formula, data, family) The formula argument uses the same syntax as lmer When handling binary outcomes, you need to specify the family argument as: family = binomial. Just exploring this data by looking at the raw proportions, it appears that probability of wheezing decreases as age increases (within each level of smoking) maternal smoking increases the probability of wheezing at each age library(dplyr) prop_summary_ohio &lt;- ohio %&gt;% group_by(smoke, age) %&gt;% summarize( prop_wheeze = mean(resp) ) prop_summary_ohio ## # A tibble: 8 x 3 ## # Groups: smoke [2] ## smoke age prop_wheeze ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 -2 0.16 ## 2 0 -1 0.149 ## 3 0 0 0.143 ## 4 0 1 0.106 ## 5 1 -2 0.166 ## 6 1 -1 0.209 ## 7 1 0 0.187 ## 8 1 1 0.139 So, we are probably going to want to include both age and smoke in our model. 1.5.2.1 A Random Intercept Model Let’s use a GLMM to explore the relationship between wheezing status and the: age of the child maternal smoking status A GLMM for wheezing status which has age and smoking status as fixed effects and random individual-specific intercepts can be expressed as \\[\\begin{equation} \\textrm{logit}\\{ p_{ij}(u_{i}) \\} = \\beta_{0} + \\beta_{age}\\textrm{age}_{ij} + \\beta_{smk}\\textrm{smoke}_{i} + u_{i} \\tag{1.6} \\end{equation}\\] Model (1.6) can be fit with the following code # id is the grouping variable ohio.intercept &lt;- glmer(resp ~ age + smoke + (1 | id), data = ohio, family = binomial) coef(summary(ohio.intercept)) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.3739539 0.27497502 -12.270038 1.311914e-34 ## age -0.1767645 0.06796698 -2.600741 9.302258e-03 ## smoke 0.4147806 0.28704052 1.445024 1.484510e-01 VarCorr(ohio.intercept) ## Groups Name Std.Dev. ## id (Intercept) 2.3432 For a binary GLMM, the estimated standard deviation for the random intercept can be a little hard to interpret, though this value seems rather large to me. One way to report this is to look at the variation in \\(p_{ij}(u_{i})\\) for different values of age and smoking status. For this purpose, you could report the interval \\(\\textrm{expit}\\big(\\hat{\\beta}_{0} + \\hat{\\beta}_{age}\\times \\textrm{age} + \\hat{\\beta}_{smk}\\times \\textrm{smoke} \\pm 1.64\\hat{\\sigma}_{u0} \\big)\\), where \\(\\textrm{expit}(x) = 1/(1 + e^{-x})\\) One way to interpret the variation visually is to randomly generate many values of \\(p_{ij}( u_{i} )\\) using the estimated distribution of \\(u_{i}\\) to simulate the values of \\(u_{i}\\). This can help us to get a sense of how much variability there is in wheezing probability across individuals. To do this, I simulated values of \\(p_{ij}( u_{i} )\\) for each combination of age/smoking status and plotted the results in 8 densities in 4 panels. It would probably be better to use some sort of bounded density estimator for these plots. beta.hat &lt;- coef(summary(ohio.intercept))[,1] n &lt;- 1000 pneg2.smoke &lt;- plogis(rnorm(n,sd=2.34) + beta.hat[1] - 2*beta.hat[2] + beta.hat[3]) #age -2 with smoke pneg2 &lt;- plogis(rnorm(n, sd=2.34) + beta.hat[1] - 2*beta.hat[2]) #age -2 w/o smoke pneg1.smoke &lt;- plogis(rnorm(n,sd=2.34) + beta.hat[1] - 1*beta.hat[2] + beta.hat[3]) #age -1 with smoke pneg1 &lt;- plogis(rnorm(n, sd=2.34) + beta.hat[1] - 1*beta.hat[2]) # age -1 w/o smoke p0.smoke &lt;- plogis(rnorm(n, sd=2.34) + beta.hat[1] + beta.hat[3]) # age 0 with smoke p0 &lt;- plogis(rnorm(n, sd=2.34) + beta.hat[1]) # age 0 w/o smoke p1.smoke &lt;- plogis(rnorm(n,sd=2.34) + beta.hat[1] + beta.hat[2] + beta.hat[3]) # age 1 with smoke p1 &lt;- plogis(rnorm(n, sd=2.34) + beta.hat[1] + beta.hat[2]) # age 1 w/o smoke par(mfrow=c(2,2), mar=c(4.1, 4.1, .5, .5)) plot(density(pneg2), lwd=2, xlab = &quot;Probability of Wheezing at Age 7&quot;, main=&quot;&quot;, col=&quot;red&quot;) d &lt;- density(pneg2.smoke) lines(d$x, d$y, lwd=2) legend(&quot;topright&quot;, legend = c(&quot;Smoke&quot;, &quot;No Smoke&quot;), col=c(&quot;black&quot;, &quot;red&quot;), bty=&#39;n&#39;, lwd=2) plot(density(pneg1), lwd=2, xlab = &quot;Probability of Wheezing at Age 8&quot;, main=&quot;&quot;, col=&quot;red&quot;) d &lt;- density(pneg1.smoke) lines(d$x, d$y, lwd=2) legend(&quot;topright&quot;, legend = c(&quot;Smoke&quot;, &quot;No Smoke&quot;), col=c(&quot;black&quot;, &quot;red&quot;), bty=&#39;n&#39;, lwd=2) plot(density(p0), lwd=2, xlab = &quot;Probability of Wheezing at Age 9&quot;, main=&quot;&quot;, col=&quot;red&quot;) d &lt;- density(p0.smoke) lines(d$x, d$y, lwd=2) legend(&quot;topright&quot;, legend = c(&quot;Smoke&quot;, &quot;No Smoke&quot;), col=c(&quot;black&quot;, &quot;red&quot;), bty=&#39;n&#39;, lwd=2) plot(density(p1), lwd=2, xlab = &quot;Probability of Wheezing at Age 10&quot;, main=&quot;&quot;, col=&quot;red&quot;) d &lt;- density(p1.smoke) lines(d$x, d$y, lwd=2) legend(&quot;topright&quot;, legend = c(&quot;Smoke&quot;, &quot;No Smoke&quot;), col=c(&quot;black&quot;, &quot;red&quot;), bty=&#39;n&#39;, lwd=2) Figure 1.3: Distribution of Wheezing probability across individuals for different values of age and smoking status References "],
["missing-data.html", "Chapter 2 Missing Data and Multiple Imputation 2.1 Missing Data in R and “Direct Approaches” for Handling Missing Data 2.2 Multiple Imputation 2.3 What is MICE doing? 2.4 Longitudinal Data 2.5 Different Missing Data Mechanisms", " Chapter 2 Missing Data and Multiple Imputation The book “Flexible Imputation of Missing Data” is a resource you also might find useful. It is available online at: https://stefvanbuuren.name/fimd/ 2.1 Missing Data in R and “Direct Approaches” for Handling Missing Data In a wide range of datasets, it is very common to encounter missing values. In R, missing values are stored as NA, meaning “Not Available”. For example, look at the airquality dataframe available in base R data(airquality) head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 You can see that the 5th observation for the Ozone variable is missing, and the 5th and 6th observations for the Solar.R variable are missing. You can use is.na to find which data entries have missing values. If is.na returns TRUE, the entry is missing. If is.na returns FALSE, the entry is not missing head( is.na(airquality) ) ## Ozone Solar.R Wind Temp Month Day ## [1,] FALSE FALSE FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE FALSE FALSE FALSE ## [4,] FALSE FALSE FALSE FALSE FALSE FALSE ## [5,] TRUE TRUE FALSE FALSE FALSE FALSE ## [6,] FALSE TRUE FALSE FALSE FALSE FALSE Computing the sum of is.na(airquality) tells us how many missing values there are in this dataset. sum( is.na(airquality) ) ## 44 missing entries in total ## [1] 44 dim( airquality ) ## Dataset has a total of 153 x 6 = 918 entries ## [1] 153 6 2.1.1 Complete Case Analysis (Listwise Deletion) Suppose we wanted to run a regression with Ozone as the response and Solar.R, Wind, and Temp as the covariates. If we do this in R, we will get the following result: air.lm1 &lt;- lm( Ozone ~ Solar.R + Wind + Temp, data = airquality ) summary( air.lm1 ) ## ## Call: ## lm(formula = Ozone ~ Solar.R + Wind + Temp, data = airquality) ## ## Residuals: ## Min 1Q Median 3Q Max ## -40.485 -14.219 -3.551 10.097 95.619 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -64.34208 23.05472 -2.791 0.00623 ** ## Solar.R 0.05982 0.02319 2.580 0.01124 * ## Wind -3.33359 0.65441 -5.094 1.52e-06 *** ## Temp 1.65209 0.25353 6.516 2.42e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 21.18 on 107 degrees of freedom ## (42 observations deleted due to missingness) ## Multiple R-squared: 0.6059,\tAdjusted R-squared: 0.5948 ## F-statistic: 54.83 on 3 and 107 DF, p-value: &lt; 2.2e-16 How is R handling all the missing values in airquality. As a default, lm conducts a complete case analysis (sometimes referred to as listwise deletion). (This is the default unless you changed the default na.action setting with options(...)) A complete case analysis for regression will first delete all rows from the dataset if any of the variables used from that row have a missing value. In this example, a row will be dropped if either the value of Ozone, Solar.R, Wind, or Temp is missing. After these observations have been deleted, the usual regression is fit to the remaining “complete” dataset. To remove all rows where there is at least one missing value, you can use na.omit: complete.air &lt;- na.omit( airquality ) ## Check that there are no missing values sum( is.na(complete.air) ) # This should be zero ## [1] 0 Let’s now fit a linear regression using the complete dataset complete.air air.lm2 &lt;- lm( Ozone ~ Solar.R + Wind + Temp, data = complete.air ) Because R does a complete-case analysis as default, the estimated regression coefficients should be the same when using the “incomplete dataset” airquality as when using the “complete dataset” complete.air ## The estimated regression coefficients should be the same round(air.lm1$coefficients, 3) ## (Intercept) Solar.R Wind Temp ## -64.342 0.060 -3.334 1.652 round(air.lm2$coefficients, 3) ## (Intercept) Solar.R Wind Temp ## -64.342 0.060 -3.334 1.652 2.1.2 Other “Direct” Methods In general, doing a complete-case analysis is not advisable. A complete-case analysis should really only be used if you are confident that the data are missing completely at random (MCAR). Roughly speaking, MCAR means that the probability of having a missing value is not related to missing or observed values of the data. A few other direct ways of handling missing data that you may have used or seen used in practice include: Mean imputation. Missing values are replaced by the value of the mean of that variable. Regression imputation. Missing values are replaced by a regression prediction from the values of the other variables. Unless the data are missing completely at random (MCAR), each of these methods will produce biased estimates of the parameters of interest and generate incorrect standard errors. 2.2 Multiple Imputation 2.2.1 Short Overview of Multiple Imputation To summarize, multiple imputation consists of the following steps: Create \\(K\\) different “complete datasets” where each dataset contains no missing data. For each of these \\(K\\) complete datasets, compute the estimates of interest. “Pool” these separate estimates to get final estimates and standard errors. The nice thing about multiple imputation is that you can always use your original analysis approach. That is, you can just apply your original analysis method to each of the \\(K\\) complete datasets. The complicated part in multiple imputation is generating the \\(K\\) complete datasets in a “valid” way. Luckily, there are a number of R packages that implement different ways of creating the \\(K\\) imputed datasets. 2.2.2 Multiple imputation with mice I will primarily focus on the mice package. mice stands for “Multivariate Imputation by Chained Equations” The mice function within the mice package is the primary function for performing multiple imputation. To use mice, just use mice(df) where df is the name of the dataframe. (Set print = FALSE if you don’t want it to print out the number of the iteration). Choose a value of seed so that the results are reproducible. Note that the default number of complete datasets returned is 5. This can be changed with the m argument. library(mice) imputed.airs &lt;- mice(airquality, print=FALSE, seed=101) The object returned by mice will have a component called imp which is a list. Each component of imp is a dataframe corresponding to a single variable in the original dataframe This dataframe will contain the imputed values for the missing values of that variable. For example, imputed.airs$imp will be a list with each component of the list being one of the variables from airquality names( imputed.airs$imp ) ## [1] &quot;Ozone&quot; &quot;Solar.R&quot; &quot;Wind&quot; &quot;Temp&quot; &quot;Month&quot; &quot;Day&quot; The Ozone component of imputed.airs$imp will be a dataframe with 37 rows and 5 columns. This is because the Ozone variable had 37 missing values, and there are 5 multiple imputations (the default number in mice) dim(imputed.airs$imp$Ozone) ## [1] 37 5 ## Imputed missing ozone values across the five multiple imputations head(imputed.airs$imp$Ozone) ## 1 2 3 4 5 ## 5 6 8 18 6 37 ## 10 12 18 27 18 30 ## 25 8 14 6 18 18 ## 26 13 1 13 37 13 ## 27 19 18 4 18 34 ## 32 40 47 45 23 18 The row names in imputed.airs$imp$Ozone correspond to the index of the observation in the original airquality dataframe. For example, the 5th observation of the Ozone variable has 6 in the 1st imputation, 8 in the 2nd imputation, 18 in the 3rd imputation, etc. …. Similarly, the Solar.R component of imputed.airs$imp will be a data frame This is because the Solar.R variable had 7 missing values, and there are 5 multiple imputations. dim(imputed.airs$imp$Solar.R) ## [1] 7 5 ## Imputed missing ozone values across the five multiple imputations head(imputed.airs$imp$Solar.R) ## 1 2 3 4 5 ## 5 131 285 274 92 139 ## 6 127 248 175 167 175 ## 11 71 71 238 115 284 ## 27 238 8 49 223 238 ## 96 258 203 229 223 291 ## 97 313 259 274 83 272 For example, the 5th observation of the Solar.R variable has 131 in the 1st imputation, 285 in the 2nd imputation, 274 in the 3rd imputation, etc. …. 2.2.2.1 with(), pool(), complete() You could use the components of imputed.airs$imp to directly fit 5 separate regression on the multiply imputed datasets and then average the results. However, this is much easier if you just use the with function from mice air.multi.imputelm &lt;- with(imputed.airs, lm( Ozone ~ Solar.R + Wind + Temp)) This will produce 5 different sets of estimates of the regression coefficients: summary(air.multi.imputelm) ## # A tibble: 20 x 6 ## term estimate std.error statistic p.value nobs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 (Intercept) -90.3 19.1 -4.72 5.44e- 6 153 ## 2 Solar.R 0.0642 0.0199 3.22 1.56e- 3 153 ## 3 Wind -2.31 0.550 -4.20 4.61e- 5 153 ## 4 Temp 1.83 0.212 8.64 8.13e-15 153 ## 5 (Intercept) -49.4 19.0 -2.60 1.02e- 2 153 ## 6 Solar.R 0.0548 0.0196 2.79 5.92e- 3 153 ## 7 Wind -3.43 0.545 -6.28 3.44e- 9 153 ## 8 Temp 1.46 0.211 6.92 1.27e-10 153 ## 9 (Intercept) -56.7 19.0 -2.98 3.36e- 3 153 ## 10 Solar.R 0.0646 0.0199 3.25 1.42e- 3 153 ## 11 Wind -3.22 0.546 -5.90 2.38e- 8 153 ## 12 Temp 1.50 0.211 7.09 4.97e-11 153 ## 13 (Intercept) -58.4 18.9 -3.09 2.41e- 3 153 ## 14 Solar.R 0.0687 0.0199 3.46 7.08e- 4 153 ## 15 Wind -3.27 0.544 -6.01 1.35e- 8 153 ## 16 Temp 1.57 0.210 7.50 5.33e-12 153 ## 17 (Intercept) -58.9 22.2 -2.66 8.69e- 3 153 ## 18 Solar.R 0.0404 0.0231 1.75 8.27e- 2 153 ## 19 Wind -3.31 0.636 -5.21 6.11e- 7 153 ## 20 Temp 1.64 0.245 6.68 4.37e-10 153 To get the “pooled estimates and standard errors” from these 5 different sets of regression coefficients use the pool function from mice: summary( pool(air.multi.imputelm) ) ## term estimate std.error statistic df p.value ## 1 (Intercept) -62.73141323 26.25695768 -2.389135 16.63162 2.903387e-02 ## 2 Solar.R 0.05855766 0.02400718 2.439173 36.55628 1.969933e-02 ## 3 Wind -3.10764673 0.75290758 -4.127527 16.76039 7.227036e-04 ## 4 Temp 1.60026617 0.27155700 5.892929 23.89788 4.511087e-06 The pooled “final estimates” of the regression coefficients are just the means of the estimated regression coefficients from the 5 multiply imputed datasets. The pooled standard error for the \\(j^{th}\\) regression coefficient is given by \\[\\begin{equation} (\\textrm{pooled } SE_{j})^{2} = \\frac{1}{K}\\sum_{k=1}^{K} SE_{jk}^{2} + \\frac{K+1}{K(K-1)}\\sum_{k=1}^{K}(\\hat{\\beta}_{jk} - \\bar{\\hat{\\beta}}_{j.})^{2}, \\end{equation}\\] where \\(SE_{jk}\\) is the standard error for the \\(j^{th}\\) regression coefficient from the \\(k^{th}\\) complete dataset, and \\(\\hat{\\beta}_{jk}\\) is the estimate of \\(\\beta_{j}\\) from the \\(k^{th}\\) complete dataset. It is sometimes useful to actually extract each of the completed datasets. This is true, for example, in longitudinal data where you may want to go back and forth between “wide” and “long” formats. To extract each of the completed datasets, you can use the complete function from mice. The following code will return the 5 complete datasets from imputed.airs completed.airs &lt;- mice::complete(imputed.airs, action=&quot;long&quot;) action = &quot;long&quot; means that it will return the 5 complete datasets as one dataframe with the individual datasets “stacked on top of each other.” completed.airs will be a dataframe that has 5 times as many rows as the airquality data frame The variable .imp is an indicator of which of the 5 imputations that row corresponds to. head(completed.airs) ## .imp .id Ozone Solar.R Wind Temp Month Day ## 1 1 1 41 190 7.4 67 5 1 ## 2 1 2 36 118 8.0 72 5 2 ## 3 1 3 12 149 12.6 74 5 3 ## 4 1 4 18 313 11.5 62 5 4 ## 5 1 5 6 131 14.3 56 5 5 ## 6 1 6 28 127 14.9 66 5 6 dim(completed.airs) ## [1] 765 8 dim(airquality) ## [1] 153 6 Using complete.airs, we can compute the multiple imputation-based estimates of the regression coefficients “by hand” This should give us the same results as when using with BetaMat &lt;- matrix(NA, nrow=5, ncol=4) for(k in 1:5) { ## Find beta.hat from kth imputed dataset BetaMat[k,] &lt;- lm(Ozone ~ Solar.R + Wind + Temp, data=completed.airs[completed.airs$.imp==k,])$coefficients } round(colMeans(BetaMat), 3) # compare with the results from using the &quot;with&quot; function ## [1] -62.731 0.059 -3.108 1.600 2.3 What is MICE doing? Suppose we have data from \\(q\\) variables \\(Z_{i1}, \\ldots, Z_{iq}\\). Let \\(\\mathbf{Z}_{mis}\\) denote the collection of missing observations and \\(\\mathbf{Z}_{obs}\\) the collection of observed values, and let \\(\\mathbf{Z} = (\\mathbf{Z}_{obs}, \\mathbf{Z}_{mis})\\). Let the vector \\(\\mathbf{Z}_{j} = (Z_{1j}, \\ldots, Z_{nj})\\) denote all the observations from variable \\(j\\). The basic idea behind multiple imputation is to, in some way, generate samples \\(\\mathbf{Z}_{mis}^{(1)}, \\ldots, \\mathbf{Z}_{mis}^{(K)}\\) from a flexible probability model \\(p(\\mathbf{Z}_{mis}|\\mathbf{Z}_{obs})\\) \\(p(\\mathbf{Z}_{mis}|\\mathbf{Z}_{obs})\\) represents the conditional distribution of \\(\\mathbf{Z}_{mis}\\) given the observed \\(\\mathbf{Z}_{obs}\\). A valid estimate \\(\\hat{\\theta}\\) of the parameter of interest \\(\\theta\\) can often be thought of as a posterior mean: \\(\\hat{\\theta} = E(\\theta|\\mathbf{Z}_{obs})\\) is the expectation of \\(\\theta\\) given the observed data \\(\\mathbf{Z}_{obs}\\). Then, \\(\\hat{\\theta}\\) can be expressed as: \\[\\begin{eqnarray} \\hat{\\theta} &amp;=&amp; E( \\theta |\\mathbf{Z}_{obs} ) = \\int E\\Big\\{ \\theta \\Big| \\mathbf{Z}_{obs}, \\mathbf{Z}_{mis} \\Big\\} p(\\mathbf{Z}_{mis}|\\mathbf{Z}_{obs}) d\\mathbf{Z}_{mis} \\nonumber \\\\ &amp;\\approx&amp; \\frac{1}{K} \\sum_{k=1}^{K} E\\Big\\{ \\theta \\Big| \\mathbf{Z}_{obs}, \\mathbf{Z}_{mis}^{(k)} \\Big\\} \\end{eqnarray}\\] There are two main approaches for setting up a model for the conditional distribution of \\(\\mathbf{Z}_{mis}|\\mathbf{Z}_{obs}\\). One approach is to directly specify a full joint model for \\(\\mathbf{Z} = (\\mathbf{Z}_{mis}, \\mathbf{Z}_{obs})\\) For example, you could assume that \\(\\mathbf{Z}\\) follows a multivariate a normal distribution. This approach is not so straightforward when you have variables of mixed type: some continuous,some binary, some categorical, etc. … The fully conditional specification (FCS) approach specifies the distribution of each variable \\(\\mathbf{Z}_{j}\\) conditional on the remaining variables \\(\\mathbf{Z}_{-j}\\). The FCS approach is the one used by mice. With the FCS approach, we assume models for \\(q\\) different conditional distributions \\[\\begin{eqnarray} p(\\mathbf{Z}_{1}&amp;|&amp;\\mathbf{Z}_{-1}, \\boldsymbol{\\eta}_{1}) \\nonumber \\\\ p(\\mathbf{Z}_{2}&amp;|&amp;\\mathbf{Z}_{-2}, \\boldsymbol{\\eta}_{2}) \\nonumber \\\\ &amp;\\vdots&amp; \\nonumber \\\\ p(\\mathbf{Z}_{q}&amp;|&amp;\\mathbf{Z}_{-q}, \\boldsymbol{\\eta}_{q}) \\end{eqnarray}\\] With mice, the parameters \\(\\eta_{j}\\) and the missing values for each variable \\(\\mathbf{Z}_{j,mis}\\) are updated one-at-a-time via a kind of Gibbs sampler. All of the missing values are imputed in one cycle of the Gibbs sampler. Multiple cycles are repeated to get multiple completed datasets. The default model for a continuous variable \\(\\mathbf{Z}_{j}\\) is to use predictive mean matching. The default model for a binary variable \\(\\mathbf{Z}_{j}\\) is logistic regression. Look at the defaultMethod argument of mice and Buuren and Groothuis-Oudshoorn (2010) for more details about how to change these default models. 2.4 Longitudinal Data A direct way to do multiple imputation with longitudinal data is to use mice on the dataset stored in wide format. Remember that in wide format, each row corresponds to a different individual. Applying multiple imputation to the wide-format dataset can account for the fact that observations across individuals will be correlated. Let’s look at the ohio data from the geepack package again library(geepack) data(ohio) head(ohio) ## resp id age smoke ## 1 0 0 -2 0 ## 2 0 0 -1 0 ## 3 0 0 0 0 ## 4 0 0 1 0 ## 5 0 1 -2 0 ## 6 0 1 -1 0 The ohio dataset is in long format. We need to first convert this into wide format. With tidyr you can convert from long to wide using spread: (Use gather to go from wide to long) library( tidyr ) ohio.wide &lt;- spread(ohio, key=age, value=resp) ## Change variable names to so that ages go from 7 to 10 names(ohio.wide) &lt;- c(&quot;id&quot;, &quot;smoke&quot;, &quot;age7&quot;, &quot;age8&quot;, &quot;age9&quot;, &quot;age10&quot;) head(ohio.wide) ## id smoke age7 age8 age9 age10 ## 1 0 0 0 0 0 0 ## 2 1 0 0 0 0 0 ## 3 2 0 0 0 0 0 ## 4 3 0 0 0 0 0 ## 5 4 0 0 0 0 0 ## 6 5 0 0 0 0 0 The variable age7 now represents the value of resp at age 7, age8 represents the value of resp at age 8, etc… reshape from base R can also be used to go from long to wide # Example of using reshape #ohio.wide2 &lt;- reshape(ohio, v.names=&quot;resp&quot;, idvar=&quot;id&quot;, timevar=&quot;age&quot;, direction=&quot;wide&quot;) The ohio dataset does not have any missing values. Let’s introduce missing values for the variable resp values by assuming that the probability of being missing is positively related to smoking status. Let \\(R_{ij}\\) be an indicator of missingness of resp for individual \\(i\\) at the \\(j^{th}\\) follow-up time. When randomly generating missing values, we will assume that: \\[\\begin{equation} P( R_{ij} = 1| \\textrm{smoke}_{i}) = \\begin{cases} 0.05 &amp; \\textrm{ if } \\textrm{smoke}_{i} = 0 \\\\ 0.3 &amp; \\textrm{ if } \\textrm{smoke}_{i} = 1 \\end{cases} \\tag{2.1} \\end{equation}\\] To generate missing values according to assumption (2.1), we can use the following R code: We will call the new data frame ohio.wide.miss ohio.wide.miss &lt;- ohio.wide m &lt;- nrow(ohio.wide.miss) ## number of individuals in study for(k in 1:m) { resp.values &lt;- ohio.wide[k, 3:6] # values of resp for individual k if(ohio.wide[k,2] == 1) { # if smoke = 1 Rij &lt;- sample(0:1, size=4, replace=TRUE, prob=c(0.7, 0.3)) } else { # if smoke = 0 Rij &lt;- sample(0:1, size=4, replace=TRUE, prob=c(0.95, 0.05)) } resp.values[Rij==1] &lt;- NA # insert NA values where Rij = 1 ohio.wide.miss[k, 3:6] &lt;- resp.values } head(ohio.wide.miss, 10) ## id smoke age7 age8 age9 age10 ## 1 0 0 0 0 NA 0 ## 2 1 0 0 0 0 0 ## 3 2 0 0 0 0 0 ## 4 3 0 0 0 0 0 ## 5 4 0 0 0 0 0 ## 6 5 0 0 0 0 0 ## 7 6 0 0 0 0 0 ## 8 7 0 0 NA 0 0 ## 9 8 0 0 0 0 0 ## 10 9 0 0 0 0 0 ohio.wide.miss now has 257 missing entries sum( is.na(ohio.wide.miss)) ## [1] 296 Before using multiple imputation with ohio.wide.miss, let’s look at the regression coefficient estimates that would be obtained with a complete case analysis. To use glmer on the missing-data version of ohio, we need to first convert ohio.wide.miss back into long form: ohio.miss &lt;- gather(ohio.wide.miss, age, resp, age7:age10) ohio.miss$age[ohio.miss$age == &quot;age7&quot;] &lt;- -2 ohio.miss$age[ohio.miss$age == &quot;age8&quot;] &lt;- -1 ohio.miss$age[ohio.miss$age == &quot;age9&quot;] &lt;- 0 ohio.miss$age[ohio.miss$age == &quot;age10&quot;] &lt;- 1 ohio.miss &lt;- ohio.miss[order(ohio.miss$id),] ## sort everything according to id ohio.miss$age &lt;- as.numeric(ohio.miss$age) head(ohio.miss) ## id smoke age resp ## 1 0 0 -2 0 ## 538 0 0 -1 0 ## 1075 0 0 0 NA ## 1612 0 0 1 0 ## 2 1 0 -2 0 ## 539 1 0 -1 0 Let’s use a random intercept model as we did in our earlier discussion of generalized linear mixed models: ## Complete case analysis library(lme4) ohio.cca &lt;- glmer(resp ~ age + smoke + (1 | id), data = ohio.miss, family = binomial) # Now look at estimated regression coefficients for complete case analysis: round(coef(summary(ohio.cca)), 4) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.8009 0.4346 -8.7459 0.0000 ## age -0.1580 0.0783 -2.0165 0.0437 ## smoke 0.2333 0.3402 0.6857 0.4929 Now, let’s use mice to create 50 “completed versions” of ohio.wide.miss imputed.ohio &lt;- mice(ohio.wide.miss, m=50, print=FALSE, seed=101) For the case of longitudinal data, we probably want to actually extract each complete dataset. (This is because many of the analysis methods such as lmer assume the data is in long form). This can be done with the following code: completed.ohio &lt;- mice::complete(imputed.ohio, &quot;long&quot;) head(completed.ohio) ## .imp .id id smoke age7 age8 age9 age10 ## 1 1 1 0 0 0 0 0 0 ## 2 1 2 1 0 0 0 0 0 ## 3 1 3 2 0 0 0 0 0 ## 4 1 4 3 0 0 0 0 0 ## 5 1 5 4 0 0 0 0 0 ## 6 1 6 5 0 0 0 0 0 completed.ohio will be a dataframe that has 50 times as many rows as the original ohio.wide data frame dim(ohio.wide) ## [1] 537 6 dim(completed.ohio) ## [1] 26850 8 The variable .imp in completed.ohio is an indicator of which of the 50 “imputed datasets” this is from: table( completed.ohio$.imp ) # Tabulate impute indicators ## ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 ## 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ## 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 537 ## 41 42 43 44 45 46 47 48 49 50 ## 537 537 537 537 537 537 537 537 537 537 For each of the 50 complete datasets, we need to convert the wide dataset into long form before using glmer: ## Multiple imputation-based estimates of regression coefficients ## for missing version of the ohio data. BetaMat &lt;- matrix(NA, nrow=50, ncol=3) for(k in 1:50) { tmp.ohio &lt;- completed.ohio[completed.ohio$.imp==k,-c(1,2)] tmp.ohio.long &lt;- gather(tmp.ohio, age, resp, age7:age10) tmp.ohio.long$age[tmp.ohio.long$age == &quot;age7&quot;] &lt;- -2 tmp.ohio.long$age[tmp.ohio.long$age == &quot;age8&quot;] &lt;- -1 tmp.ohio.long$age[tmp.ohio.long$age == &quot;age9&quot;] &lt;- 0 tmp.ohio.long$age[tmp.ohio.long$age == &quot;age10&quot;] &lt;- 1 tmp.ohio.long$age &lt;- as.numeric(tmp.ohio.long$age) ohio.tmpfit &lt;- glmer(resp ~ age + smoke + (1 | id), data = tmp.ohio.long, family = binomial) BetaMat[k,] &lt;- coef(summary(ohio.tmpfit))[,1] } The multiple imputation-based estimates of the regression coefficients for the missing version of ohio are: round(colMeans(BetaMat), 4) ## [1] -3.6032 -0.1138 0.2501 Compare the above regression coefficients with those from the complete-case analysis. 2.5 Different Missing Data Mechanisms For this section, we will consider the setup where we have \\(n\\) “observations” and \\(q\\) “variables”: denoted by \\(Z_{i1}, \\ldots, Z_{iq}\\), for \\(i = 1, \\ldots, n\\). Let \\(\\mathbf{Z}_{mis}\\) denote the collection of missing observations and \\(\\mathbf{Z}_{obs}\\) the collection of observed values, and let \\(\\mathbf{Z} = (\\mathbf{Z}_{obs}, \\mathbf{Z}_{mis})\\). The variables \\(R_{ij}\\) are defined as \\[\\begin{equation} R_{ij} = \\begin{cases} 1 &amp; \\textrm{ if } Z_{ij} \\textrm{ is missing } \\\\ 0 &amp; \\textrm{ if } Z_{ij} \\textrm{ is observed } \\end{cases} \\end{equation}\\] 2.5.1 Missing Completely at Random (MCAR) The missingness mechanism is said to be MCAR if \\[\\begin{equation} P(R_{ij} = 1|\\mathbf{Z}_{obs}, \\mathbf{Z}_{mis}) = P(R_{ij}=1) \\end{equation}\\] 2.5.2 Missing at Random (MAR) The missingness mechanism is said to be MAR \\[\\begin{equation} P(R_{ij} = 1|\\mathbf{Z}_{obs}, \\mathbf{Z}_{mis}) = P(R_{ij}=1|\\mathbf{Z}_{obs}) \\end{equation}\\] 2.5.3 Missing not at Random (MNAR) If the missingness mechanism is classified as missing not at random (MNAR), the probability \\(P(R_{ij} = 1|\\mathbf{Z}_{obs}, \\mathbf{Z}_{mis})\\) cannot be factorized into a simpler form. References "],
["nonpar-regression.html", "Chapter 3 Nonparametric Regression with Longitudinal Data 3.1 Notation 3.2 Kernel Smoothing 3.3 Regression Splines", " Chapter 3 Nonparametric Regression with Longitudinal Data 3.1 Notation For longitudinal data, we will again use the following notation: Individual \\(i\\) has observations for both the outcome and the covariates at times \\(t_{i1}, \\ldots, t_{in_{i}}\\) \\(Y_{ij}\\) is the outcome for individual \\(i\\) at time \\(t_{ij}\\). \\(\\mathbf{x}_{ij}\\) is the vector of covariates at time \\(t_{ij}\\). The \\(i^{th}\\) individual has \\(n_{i}\\) observations: \\(Y_{i1}, \\ldots, Y_{in_{i}}\\). There will be \\(m\\) individuals in the study (so \\(1 \\leq i \\leq m\\)). A general regression model relating \\(Y_{ij}\\) and \\(\\mathbf{x}_{ij}\\) is the following: \\[\\begin{equation} Y_{ij} = \\mu( \\mathbf{x}_{ij} ) + \\varepsilon_{ij} \\nonumber \\end{equation}\\] Here, \\(\\mu(\\mathbf{x}_{ij}) = E(Y_{ij}| \\mathbf{x}_{ij})\\) is the “mean function”. In nonparametric approaches to estimating \\(\\mu(\\cdot)\\), we will try to estimate \\(\\mu(\\mathbf{x})\\) without making any strong assumptions about the form of \\(\\mu( \\mathbf{x} )\\). Basically, in a nonparametric approach, there is not a fixed set of parameters describing the mean function that does not change as the sample size grows. 3.2 Kernel Smoothing 3.2.1 Description of Kernel Regression With kernel regression, we estimate the mean function \\(\\mu(\\mathbf{x})\\) at \\(\\mathbf{x}\\) by taking a weighted “local average” of the \\(Y_{ij}\\) around \\(\\mathbf{x}\\). Specifically, the kernel regression estimate of \\(\\mu(\\cdot)\\) at a point \\(\\mathbf{x}\\) can be expressed as \\[\\begin{equation} \\hat{\\mu}( \\mathbf{x} ) = \\sum_{i=1}^{m}\\sum_{j=1}^{n_{i}} w_{ij}(\\mathbf{x})Y_{ij} \\end{equation}\\] The “weights” at the point \\(\\mathbf{x}\\) are given by \\[\\begin{equation} w_{ij}(\\mathbf{x}) = \\frac{ K\\Big( \\frac{\\mathbf{x} - \\mathbf{x}_{ij}}{ h_{n} }\\Big) }{ \\sum_{i=1}^{m}\\sum_{j=1}^{n_{i}} K\\Big( \\frac{\\mathbf{x} - \\mathbf{x}_{ij}}{ h_{n} }\\Big) } \\tag{3.1} \\end{equation}\\] When using the weights (3.1), \\(\\hat{\\mu}(\\mathbf{x})\\) is known as the Nadaraya-Watson esitmator. The function \\(K(\\cdot)\\) in (3.1) is referred to as the “kernel function”. The kernel function \\(K(\\cdot)\\) is: A smooth nonnegative function Symmetric around \\(0\\) Has a mode at \\(0\\) and decays the further you go away from \\(0\\) A common choice of \\(K(\\cdot)\\) is the Gaussian kernel \\[\\begin{equation} K(\\mathbf{u}) = \\exp\\Big\\{ - \\frac{||\\mathbf{u}||^{2}}{2} \\Big\\} \\end{equation}\\] Observations where \\(\\mathbf{x}_{ij}\\) is “close” to \\(\\mathbf{x}\\) will be given a larger weight \\(w_{ij}(\\mathbf{x})\\) because \\(||\\mathbf{x} - \\mathbf{x}_{ij}||^{2}\\) will be small. Similarly, observations where \\(\\mathbf{x}_{ij}\\) is “far away” from \\(\\mathbf{x}\\) will be given a smaller weight \\(w_{ij}(\\mathbf{x})\\) because \\(||\\mathbf{x} - \\mathbf{x}_{ij}||^{2}\\) will be small. The term \\(h_{n} &gt; 0\\) is referred to as the bandwidth. The bandwidth determines how many observations have a strong impact on the value of \\(\\hat{\\mu}( \\mathbf{x} )\\). If the bandwidth \\(h_{n}\\) is small, observations close to \\(\\mathbf{x}\\) will largely determine the value of \\(\\hat{\\mu}(\\mathbf{x})\\). If the bandwidth \\(h_{n}\\) is large, the value of \\(\\hat{\\mu}(\\mathbf{x})\\) will be more heavily influenced by a larger number of observations. Kernel regression estimates with a smaller bandwidth will be more “wiggly” and non-smooth. Kernel regression estimates with a larger bandwidth will be more smooth. 3.2.2 Kernel Regression in the sleepstudy data Again, let’s look at the sleepstudy data from the lme4 package. The sleepstudy data had 18 participants with reaction time measured across 10 days. library(lme4) ## Loading required package: Matrix data(sleepstudy) head(sleepstudy) ## Reaction Days Subject ## 1 249.5600 0 308 ## 2 258.7047 1 308 ## 3 250.8006 2 308 ## 4 321.4398 3 308 ## 5 356.8519 4 308 ## 6 414.6901 5 308 We can estimate the marginal mean function for the sleepstudy data by using a GEE. We will assume that reaction time is a linear function of time on study: That is, we will assume that \\(\\mu(t) = \\beta_{0} + \\beta_{1} t\\). library(geepack) ## Use AR(1) correlation structure sleep.gee &lt;- geeglm(Reaction ~ Days, data=sleepstudy, id=Subject, corstr=&quot;ar1&quot;) To get the value of the estimated regression function, we can use the first \\(10\\) fitted values (because the fitted values for each subject are the same as the overall mean function) ## Estimated mean function at each time point gee.regfn &lt;- sleep.gee$fitted.values[1:10,1] ### Now plot the estimated mean function plot(sleepstudy$Days, sleepstudy$Reaction, las=1, ylab=&quot;Reaction Time&quot;, xlab=&quot;Days&quot;, main=&quot;Sleepstudy: GEE estimate of Mean Function&quot;, type=&quot;n&quot;) points(sleepstudy$Days, sleepstudy$Reaction, pch=16, cex=0.8) lines(0:9, gee.regfn, lwd=2, col=&quot;red&quot;) To find a kernel regression estimate of the mean function, you can use the ksmooth function in R. One thing to note is that ksmooth only works for a scalar covariate. Using a bandwidth of \\(0.5\\) and a Gaussian kernel, we can find the kernel regression estimate of the mean function with the following R code: sleep.kernel &lt;- ksmooth(sleepstudy$Days, sleepstudy$Reaction, kernel=&quot;normal&quot;, bandwidth = 0.5) This will return a list with an “x vector” and a “y vector”. The x vector will be the vector of points at which the regression function is estimated. The y vector will be a vector containing the estimated values of the regression function. Let’s plot the estimated mean function to see what it looks like: plot(sleepstudy$Days, sleepstudy$Reaction, las=1, ylab=&quot;Reaction Time&quot;, xlab=&quot;Days&quot;, main=&quot;Sleepstudy: Kernel Regression with Bandwidth = 0.5&quot;, type=&quot;n&quot;) points(sleepstudy$Days, sleepstudy$Reaction, pch=16, cex=0.8) lines(sleep.kernel$x, sleep.kernel$y, lwd=2, col=&quot;red&quot;) This bandwidth looks too small. There are clear “near jumps” in between some of the days. We can try a bandwidth of \\(1\\) to see if we can smooth this out a bit. sleep.kernel.bw1 &lt;- ksmooth(sleepstudy$Days, sleepstudy$Reaction, kernel=&quot;normal&quot;, bandwidth = 1) plot(sleepstudy$Days, sleepstudy$Reaction, las=1, ylab=&quot;Reaction Time&quot;, xlab=&quot;Days&quot;, main=&quot;Sleepstudy: Kernel Regression with Bandwidth = 1&quot;, type=&quot;n&quot;) points(sleepstudy$Days, sleepstudy$Reaction, pch=16, cex=0.8) lines(sleep.kernel.bw1$x, sleep.kernel.bw1$y, lwd=2, col=&quot;red&quot;) 3.2.3 Bandwidth Selection The bandwidth can be chosen to get a level of smoothness that looks good visually. For example, when observations are only collected daily like in the sleepstudy you will probably want to choose a bandwidth so that the estimated mean function does not have obvious bumps in between days. To choose the bandwidth \\(h_{n} &gt; 0\\) using a formal criterion, a common approach is to use leave-one-out cross-validation. In the context of longitudinal data, it is usually suggested that you leave one subject out at a time rather than one observation at a time (Rice and Silverman (1991)). The reason for this is that the subject-level leave-one-out cross-validation score is a good estimate of the mean-squared prediction error of regardless of what the correlation structure is for the within-subject outcomes. This is not the case when using observation-level leave-one-out cross-validation. The subject-level leave-one-out cross-validation score for a given bandwidth choice is defined as \\[\\begin{equation} \\textrm{LOOCV}(h_{n}) = \\sum_{i=1}^{n}\\sum_{j=1}^{m_{i}} \\{ Y_{ij} - \\hat{\\mu}_{h_{n}}^{(-i)}(\\mathbf{x}_{ij}) \\}^{2} \\end{equation}\\] Here, \\(\\hat{\\mu}_{h_{n}}^{(-i)}(\\mathbf{x}_{ij})\\) is the mean function estimate when using bandwidth \\(h_{n}\\) and when ignoring the data from subject \\(i\\). 3.2.4 Another Example: The Bone Data As another example, we can use the “bone” dataset. This is a longitudinal dataset with typically 2 or 3 observations per individual. bonedat &lt;- read.table(&quot;https://web.stanford.edu/~hastie/ElemStatLearn/datasets/bone.data&quot;, header=TRUE) head(bonedat) ## idnum age gender spnbmd ## 1 1 11.70 male 0.018080670 ## 2 1 12.70 male 0.060109290 ## 3 1 13.75 male 0.005857545 ## 4 2 13.25 male 0.010263930 ## 5 2 14.30 male 0.210526300 ## 6 2 15.30 male 0.040843210 For this data, the interest would be to model the mean function for bone mineral density (the variable spnbmd) as a function of age We can compute the leave-one-out cross-validation score for the bone data for different values of \\(h_{n}\\) (here \\(0.1 \\leq h_{n} \\leq 1\\)) with the following code: nh &lt;- 200 hh &lt;- seq(.1, 1, length.out=nh) LOOCV &lt;- rep(0, nh) subj.list &lt;- unique(bonedat$idnum) nsubj &lt;- length(subj.list) for(k in 1:nh) { ss &lt;- 0 for(i in 1:nsubj) { ind &lt;- bonedat$idnum==subj.list[i] yy &lt;- bonedat$spnbmd[-ind] xx &lt;- bonedat$age[-ind] tmp &lt;- ksmooth(xx, yy, kernel=&quot;normal&quot;, bandwidth = hh[k], x.points=bonedat$age[ind]) mu.hat &lt;- tmp$y ss &lt;- ss + sum((bonedat$spnbmd[ind] - mu.hat)^2) } LOOCV[k] &lt;- ss } hh[which.min(LOOCV)] ## best seems to be 0.1 ## [1] 0.1 In this case, the best bandwidth was \\(0.1\\) according to the subject-level leave-one-out cross-validation criterion. The kernel regression estimate of the mean function with the bandwidth of \\(0.1\\) is plotted below: bone.kernel &lt;- ksmooth(bonedat$age, bonedat$spnbmd, kernel=&quot;normal&quot;, bandwidth = 0.1, x.points=seq(9.4, 25, length.out=100)) plot(bonedat$age, bonedat$spnbmd, las=1, ylab=&quot;spnbmd&quot;, xlab=&quot;age&quot;, main=&quot;Bone Data: Kernel Regression with Bandwidth = 0.1&quot;, type=&quot;n&quot;) points(bonedat$age, bonedat$spnbmd, pch=16, cex=0.8) lines(bone.kernel$x, bone.kernel$y, lwd=2, col=&quot;red&quot;) Using a bandwidth of \\(1\\) gives a smoother mean function estimate. The performance of kernel regression methods can degrade quickly as we move to higher dimensions. The convergence rate of the estimated regression function to the true regression function slows substantially as we the dimension of the covariates \\(\\mathbf{x}_{ij}\\). “Curse of dimensionality” - need very large datasets to have a sufficient number of observations near a given point \\(\\mathbf{x}\\). Another approach when using multiple covariates is to use generalized additive models. With generalized additive models, the mean function is expressed as the sum of several univariate nonparametric functions: \\[\\begin{equation} \\mu(\\mathbf{x}) = \\beta_{0} + \\mu(x_{1}) + \\mu(x_{2}) + \\ldots + \\mu(x_{p}) \\end{equation}\\] 3.3 Regression Splines 3.3.1 Overview Using regression splines is another common nonparametric approach for estimating a mean function. The most common type of spline used in the context of nonparametric regression is the cubic spline. Definition: A cubic spline with knots \\(u_{1} &lt; u_{2} &lt; \\ldots &lt; u_{q}\\) is a function \\(f(x)\\) such that \\(f(x)\\) is a cubic function over each of the intervals \\((-\\infty, u_{1}], [u_{1}, u_{2}], \\ldots, [u_{q-1}, u_{q}], [u_{q}, \\infty)\\). \\(f(x)\\), \\(f&#39;(x)\\), and \\(f&#39;&#39;(x)\\) are all continuous functions. A commonly used set of basis functions for the set of cubic splines with knots \\(u_{1} &lt; u_{2} &lt; \\ldots &lt; u_{q}\\) is the B-spline basis functions. This means that if \\(\\varphi_{1, B}(x), \\ldots, \\varphi_{q+4, B}(x)\\) are the B-spline basis functions for the set of cubic splines with knots \\(u_{1} &lt; u_{2} &lt; \\ldots &lt; u_{q}\\), we can represent any cubic spline estimate of the mean function as \\[\\begin{equation} \\hat{\\mu}(x) = \\sum_{j=1}^{q+4} \\hat{\\beta}_{1}\\varphi_{j, B}(x) \\end{equation}\\] The nice thing about using regression splines is that they can estimated in the same way as you would in a typical regression setting. The columns of the design matrix will be filled in with the values of \\(\\varphi_{j,B}(x_{i})\\). 3.3.2 Regression Splines with Longitudinal Data in R Regression splines can be fitted in R by using the splines package library(splines) The bs function in splines generates the B-spline “design” matrix bs(x, df, knots, degree) x - vector of covariates values. This can also just be the name of a variable when bs is used inside a function such as geeglm. df - the “degrees of freedom”. For a cubic spline this is actually \\(q + 3\\) rather than \\(q + 4\\). If you just enter df, the bs function will pick the knots for you. knots - the vector of knots. If you don’t want to pick the knots, you can just enter a number for the df. degree - the degree of the piecewise polynomial. Typically, degree=3 which would be a cubic spline. You can directly use regression splines within the “GEE framework”. In this case, you can model the marginal mean (or part of the marginal mean function) with a spline. For example, with the bone data, suppose we want to fit separate curves for the male and female groups. We could express the mean function \\(\\mu(\\cdot)\\) as \\[\\begin{equation} \\mu(t_{ij}) = f_{0}(t_{ij}) + A_{ij}f_{1}(t_{ij}) \\tag{3.2} \\end{equation}\\] \\(f_{0}(\\cdot)\\) and \\(f_{1}(\\cdot)\\) would be modeled with regression splines. \\(t_{ij}\\) is the value of age for observation (i,j) \\(A_{ij} = 1\\) if the \\((i,j)\\) observation corresponds to a male individual and \\(A_{ij} = 0\\) if the \\((i,j)\\) observation corresponds to a female individual. To fit model (3.2) using the geepack package, you can use the following code library(splines) gee.bone &lt;- geeglm(spnbmd ~ bs(age, df=6) + gender*bs(age,df=6), id=idnum, data=bonedat) We can plot the estimated mean functions by first extracting the fitted values for both the male and female groups: male.fitted &lt;- gee.bone$fitted.values[bonedat$gender==&quot;male&quot;] male.age &lt;- bonedat$age[bonedat$gender==&quot;male&quot;] female.fitted &lt;- gee.bone$fitted.values[bonedat$gender==&quot;female&quot;] female.age &lt;- bonedat$age[bonedat$gender==&quot;female&quot;] Now, plot the fitted curves for both groups plot(bonedat$age, bonedat$spnbmd, lwd=1, xlab=&quot;age&quot;, ylab=&quot;spnbmd&quot;, main=&quot;Regression Splines for the Bone Data&quot;) points(bonedat$age[bonedat$gender==&quot;male&quot;], bonedat$spnbmd[bonedat$gender==&quot;male&quot;], cex=0.8) points(bonedat$age[bonedat$gender==&quot;female&quot;], bonedat$spnbmd[bonedat$gender==&quot;female&quot;], pch=16, cex=0.8) lines(male.age[order(male.age)], male.fitted[order(male.age)], col=&quot;red&quot;, lwd=2) lines(female.age[order(female.age)], female.fitted[order(female.age)], col=&quot;blue&quot;, lwd=2) legend(&quot;topright&quot;, legend=c(&quot;Male&quot;, &quot;Female&quot;), col=c(&quot;red&quot;, &quot;blue&quot;), lwd=3, bty=&#39;n&#39;) References "],
["glmm-lasso.html", "Chapter 4 Sparse Regression for Longitudinal Data 4.1 Sparse regression methods 4.2 The Lasso with longitudinal data 4.3 Lasso for LMMs and GLMMs in R 4.4 Cross-Validation for Longitudinal Data 4.5 GLMM-Lasso with Binary Outcomes", " Chapter 4 Sparse Regression for Longitudinal Data 4.1 Sparse regression methods Sparse regression methods typically involve estimating the regression coefficients by minimizing a penalized least-squares criterion. The most well-known sparse regression method is the lasso. With the lasso, the regression coefficients \\(\\boldsymbol{\\beta}\\) are found by minimizing the following penalized least-squares criterion: \\[\\begin{equation} Q_{\\lambda}(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n}(y_{i} - \\mathbf{x}_{i}^{T}\\boldsymbol{\\beta})^{2} + \\lambda \\sum_{j=1}^{p}|\\beta_{j}| \\end{equation}\\] An advantage of the lasso is that many of the individual estimated regression coefficients \\(\\hat{\\beta}_{j}\\) will equal zero exactly. So, you can think of the lasso as performing variable selection The regression coefficient estimates which are non-zero will be the “selected” variables. \\(\\lambda \\geq 0\\) in the \\(L_{1}\\) penalty function \\(\\lambda \\sum_{j=1}^{p}|\\beta_{j}|\\) is referred to as the “tuning parameter”. If \\(\\lambda\\) is large enough, all of the estimated regression coefficients will be equal to zero. If \\(\\lambda = 0\\), then the estimated regression coefficients will be the same as the usual least-squares estimates. For intermediate values of \\(\\lambda\\), some regression coefficients will be “selected” with the remaining regression coefficient estimates being set to zero. The value of the tuning parameter \\(\\lambda\\) is usually chosen through cross-validation. Lasso paths: You can plot the values of the regression coefficients for different values of \\(\\lambda\\) to get a sense of which variables are selected first. In addition to performing variable selection, the lasso also shrinks the regression coefficients towards zero. This can improve predictive performance when the regression coefficient estimates have high variance. This can occur, for example, if the matrix \\(\\mathbf{X}^{T}\\mathbf{X}\\) is poorly conditioned. Another advantage of the lasso and other penalized regression methods is that they can be used when the number of variables is greater than the number of observations. 4.2 The Lasso with longitudinal data Recall our notation for longitudinal data: \\(Y_{ij}\\) - outcome for individual \\(i\\) at time \\(t_{ij}\\). \\(\\mathbf{x}_{ij}\\) - vector of covariates for individual \\(i\\) at time \\(t_{ij}\\). \\(\\mathbf{z}_{ij}\\) - vector determining form of random effects for individual \\(i\\) at time \\(t_{ij}\\) With penalized regression for longitudinal data, the linear mixed model still assumes that \\[\\begin{eqnarray} Y_{ij} &amp;=&amp; \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + b_{ij} + e_{ij} \\nonumber \\\\ &amp;=&amp; \\beta_{0} + \\mathbf{x}_{ij}^{T}\\boldsymbol{\\beta} + \\mathbf{z}_{ij}^{T}\\mathbf{u}_{i} + e_{ij} \\tag{4.1} \\end{eqnarray}\\] \\(\\boldsymbol{\\beta}\\) - vector of fixed effects \\(\\mathbf{u}_{i}\\) - vector of random effects \\(\\mathbf{u}_{i} \\sim \\textrm{Normal}(0, \\boldsymbol{\\Sigma})\\). \\(e_{ij} \\sim \\textrm{Normal}(0, \\sigma^{2})\\). Let \\(\\mathbf{Y}\\) be the vector of responses stacked in “long form”: \\(\\mathbf{Y} = (Y_{11}, Y_{12}, ...., Y_{mn_{m}})\\) Under the assumed linear mixed model (4.1), we have \\[\\begin{equation} \\mathbf{Y} \\sim \\textrm{Normal}(\\mathbf{X}\\boldsymbol{\\beta}, \\mathbf{V}) \\end{equation}\\] \\(\\mathbf{V} = \\mathbf{Z}\\textrm{Cov}(\\mathbf{u})\\mathbf{Z}^{T} + \\sigma^{2}\\mathbf{I}\\). \\(\\textrm{Cov}(\\mathbf{u})\\) is the covariance matrix for the “stacked” vector of random effects \\(\\mathbf{u}\\). \\(\\textrm{Cov}(\\mathbf{u})\\) will be a “block diagonal” matrix with the blocks being \\(\\boldsymbol{\\Sigma}\\). \\[\\begin{equation} \\textrm{Cov}(\\mathbf{u}) = \\begin{bmatrix} \\boldsymbol{\\Sigma} &amp; \\mathbf{0} &amp; \\mathbf{0} &amp; \\ldots &amp; \\mathbf{0} \\\\ \\mathbf{0} &amp; \\boldsymbol{\\Sigma} &amp; \\mathbf{0} &amp; \\ldots &amp; \\mathbf{0} \\\\ \\mathbf{0} &amp; \\mathbf{0} &amp; \\boldsymbol{\\Sigma} &amp; \\ldots &amp; \\mathbf{0} \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\vdots \\\\ \\mathbf{0} &amp; \\mathbf{0} &amp; \\mathbf{0} &amp; \\ldots &amp; \\boldsymbol{\\Sigma} \\end{bmatrix} \\end{equation}\\] — With the LMM-Lasso (Schelldorfer, Bühlmann, and De Geer (2011)), you estimate the vector of fixed effects \\(\\boldsymbol{\\beta}\\) and the parameters in \\(\\mathbf{V}\\) by minimizing the following penalized negative log-likelihood: \\[\\begin{equation} Q_{\\lambda}(\\boldsymbol{\\beta}, \\mathbf{V}) = \\frac{1}{2}\\log\\det(\\mathbf{V}) + \\frac{1}{2}(\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\beta})^{T}\\mathbf{V}^{-1} (\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\beta}) + \\lambda\\sum_{j=1}^{p}\\beta_{j} \\end{equation}\\] In Schelldorfer, Bühlmann, and De Geer (2011), suggest using a Bayesian information criterion (BIC) to choose the tuning parameter \\(\\lambda\\). This is defined as \\[\\begin{equation} \\textrm{BIC}_{\\lambda} = -2 \\times \\textrm{log-likelihood} + \\log(n) \\times df_{\\lambda} \\end{equation}\\] \\(df_{\\lambda}\\) is equal to the number of non-zero regression coefficients when using \\(\\lambda\\) plus the number of paramaters in the matrix \\(\\mathbf{V}\\). 4.3 Lasso for LMMs and GLMMs in R One R package which fits linear mixed models and generalized linear mixed models with the Lasso penalty is the glmmLasso package. There are also methods and R implementations for penalized regression with GEEs. See, for example, the paper: Wang, Zhou, and Qu (2012) I won’t cover that today. 4.3.1 Soccer Data To briefly show how this works, we can use the soccer data from the glmmLasso package. This is actually not a longitudinal dataset, but it does have repeated measures. This dataset has 54 observations with 23 unique teams. Each row in this dataset corresponds to data taken from a single team in a single season. library(glmmLasso) data(&quot;soccer&quot;) dim(soccer) ## 54 observations and 16 variables ## [1] 54 16 head(soccer) ## pos team points transfer.spendings transfer.receits yellow.card ## 338 12 1. FC Koeln 39 5150000 750000 70 ## 357 13 1. FC Koeln 38 11500000 900000 70 ## 324 16 1. FC Nuernberg 31 5400000 6350000 61 ## 360 16 1. FC Nuernberg 31 450000 1900000 53 ## 353 9 1. FSV Mainz 05 47 3000000 200000 58 ## 333 7 1899 Hoffenheim 55 11950000 125000 70 ## yellow.red.card red.card unfair.score ave.unfair.score ball.possession ## 338 2 2 86 2.53 49.02 ## 357 1 3 88 2.59 48.23 ## 324 3 0 70 2.06 52.02 ## 360 2 0 59 1.74 50.41 ## 353 1 3 76 2.24 47.76 ## 333 3 3 94 2.76 49.64 ## tackles capacity total.attend ave.attend sold.out ## 338 49.17 50076 853767 50222 11 ## 357 48.94 50076 822102 48359 6 ## 324 51.26 48548 742739 43691 2 ## 360 49.61 48548 719705 42336 5 ## 353 49.44 20300 342350 20138 11 ## 333 50.38 30164 477414 28083 17 length(unique(soccer$team)) ## 23 unique teams ## [1] 23 The variable team represents the soccer team. Each team has 2 or 3 seasons of data. The variable points represents the total number of points scored over the course of the season. There are a number of other variables that may explain some of the variation in points scored: ball.possession, tackles, etc. We will use points and 10 of the other variables as the fixed-effects covariates. It is common in practice to center and scale the covariates before running the lasso: soccer[,c(4,5,9:16)] &lt;- scale(soccer[,c(4,5,9:16)], center=TRUE, scale=TRUE) soccer &lt;- data.frame(soccer) To fit an lmm-lasso with \\(\\lambda = 100\\) and a random intercept for each team, we can use the following code lm.lambda100 &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=100, data = soccer) Note that the random effects model (i.e., the model for \\(b_{ij}\\)) is specified through the rnd argument. team = ~1 means that \\(b_{ij} = u_{i}\\) for each \\(i,j\\). To look at the summary of the parameter estimates, use summary summary(lm.lambda100) ## Call: ## glmmLasso(fix = points ~ transfer.spendings + ave.unfair.score + ## ball.possession + tackles + ave.attend + sold.out, rnd = list(team = ~1), ## data = soccer, lambda = 100) ## ## ## Fixed Effects: ## ## Coefficients: ## Estimate StdErr z.value p.value ## (Intercept) 43.74460 NA NA NA ## transfer.spendings 3.13598 NA NA NA ## ave.unfair.score 0.00000 NA NA NA ## ball.possession 1.00441 NA NA NA ## tackles 0.51338 NA NA NA ## ave.attend 1.55091 NA NA NA ## sold.out 3.54361 NA NA NA ## ## Random Effects: ## ## StdDev: ## team ## team 2.431689 All coefficient estimates are non-zero except for the “average unfariness score per match” variable If we set \\(\\lambda = 500\\), all of the coefficient estimates will be zero: lm.lambda500 &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=500, data = soccer) summary(lm.lambda500) ## Call: ## glmmLasso(fix = points ~ transfer.spendings + ave.unfair.score + ## ball.possession + tackles + ave.attend + sold.out, rnd = list(team = ~1), ## data = soccer, lambda = 500) ## ## ## Fixed Effects: ## ## Coefficients: ## Estimate StdErr z.value p.value ## (Intercept) 42.575 NA NA NA ## transfer.spendings 0.000 NA NA NA ## ave.unfair.score 0.000 NA NA NA ## ball.possession 0.000 NA NA NA ## tackles 0.000 NA NA NA ## ave.attend 0.000 NA NA NA ## sold.out 0.000 NA NA NA ## ## Random Effects: ## ## StdDev: ## team ## team 11.88068 We can find the value of BIC by looking at the $bic component of lm.lambda100 lm.lambda100$bic ## [,1] ## [1,] -122872.8 4.3.2 Choosing the tuning parameter for the soccer data Because \\(\\lambda = 500\\) implies that all of the coefficient estimates are zero, we know that the “best” value of \\(\\lambda\\) should be somewhere between \\(0\\) and \\(500\\). Let’s compute the BIC across a grid of \\(\\lambda\\) values from \\(0\\) to \\(500\\) and plot the result lam.seq &lt;- seq(0, 500, by=5) BIC.values &lt;- rep(0, length(lam.seq)) for(k in 1:length(lam.seq)) { lm.tmp &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=lam.seq[k], data = soccer) BIC.values[k] &lt;- lm.tmp$bic } plot(lam.seq, BIC.values, xlab=expression(lambda), ylab=&quot;BIC&quot;, main=&quot;BIC for soccer data&quot;) It looks like the lowest BIC value is in between 0 and 50. Let’s plot the BIC values for a denser grid of \\(\\lambda\\) values between 0 and 50 lam.seq &lt;- seq(0, 50, by=1) BIC.values &lt;- rep(0, length(lam.seq)) for(k in 1:length(lam.seq)) { lm.tmp &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=lam.seq[k], data = soccer) BIC.values[k] &lt;- lm.tmp$bic } plot(lam.seq, BIC.values, xlab=expression(lambda), ylab=&quot;BIC&quot;, main=&quot;BIC for soccer data&quot;) lines(lam.seq, BIC.values) The best value of \\(\\lambda\\) according to the BIC criterion is \\(16\\): lam.seq[which.min(BIC.values)] ## [1] 16 Let’s look at the regression coefficient estimates using \\(\\lambda = 16\\) lm.lambda16 &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=16, data = soccer) summary(lm.lambda16) ## Call: ## glmmLasso(fix = points ~ transfer.spendings + ave.unfair.score + ## ball.possession + tackles + ave.attend + sold.out, rnd = list(team = ~1), ## data = soccer, lambda = 16) ## ## ## Fixed Effects: ## ## Coefficients: ## Estimate StdErr z.value p.value ## (Intercept) 43.858182 NA NA NA ## transfer.spendings 2.779951 NA NA NA ## ave.unfair.score -0.130634 NA NA NA ## ball.possession -0.082063 NA NA NA ## tackles 0.000000 NA NA NA ## ave.attend 3.361656 NA NA NA ## sold.out 4.970522 NA NA NA ## ## Random Effects: ## ## StdDev: ## team ## team 5.632609 4.4 Cross-Validation for Longitudinal Data Cross-validation without any longitudinal or repeated-measures structure is pretty straightforward. For longitudinal data, the type of cross-validation can depend on the prediction goals/context. In many cases, it makes sense to hold out random individuals (or groups) in each test set. In other words, each training set would look like the following: \\[\\begin{equation} \\mathcal{T}_{r} = \\{ \\textrm{ all } (Y_{ij}, \\mathbf{x}_{ij}), \\textrm{such that } i \\in \\mathcal{S} \\} \\end{equation}\\] where \\(\\mathcal{S}\\) is a random subset of indeces. In cases where you are thinking of using your model for forecasting, it may make sense to use an alternative strategy for cross-validation. In this case, you may want to construct the test sets so that they only contain observations at “future” time points when compared with the training set. Let’s try doing 5-fold cross-validation with the soccer data. To do this, it’s easier to just create a team id variable first team.labels&lt;-data.frame(team=unique(soccer$team),team.id=as.numeric(unique(soccer$team))) soccer &lt;- merge(soccer, team.labels, by=&quot;team&quot;) head(soccer) ## team pos points transfer.spendings transfer.receits yellow.card ## 1 1. FC Koeln 12 39 -0.47350170 -0.6774385 70 ## 2 1. FC Koeln 13 38 -0.08019776 -0.6624274 70 ## 3 1. FC Nuernberg 16 31 -0.45801729 -0.1170267 61 ## 4 1. FC Nuernberg 16 31 -0.76460855 -0.5623539 53 ## 5 1. FSV Mainz 05 9 47 -0.60666760 -0.7324789 58 ## 6 1899 Hoffenheim 7 55 -0.05232583 -0.7399844 70 ## yellow.red.card red.card unfair.score ave.unfair.score ball.possession ## 1 2 2 1.0002188 1.0005114 -0.2847609 ## 2 1 3 1.1494227 1.1527733 -0.5154026 ## 3 3 0 -0.1934125 -0.1922072 0.5910938 ## 4 2 0 -1.0140340 -1.0042709 0.1210518 ## 5 1 3 0.2541992 0.2645786 -0.6526198 ## 6 3 3 1.5970344 1.5841821 -0.1037509 ## tackles capacity total.attend ave.attend sold.out team.id ## 1 -0.5594251 0.1908255 0.52774513 0.52776771 0.9696315 1 ## 2 -0.7152112 0.1908255 0.41510241 0.41510371 -0.1303706 1 ## 3 0.8561964 0.1027586 0.13278238 0.13280873 -1.0103723 2 ## 4 -0.2613995 0.1027586 0.05084294 0.05086578 -0.3503711 2 ## 5 -0.3765458 -1.5253268 -1.29153165 -1.29154724 0.9696315 3 ## 6 0.2601452 -0.9568110 -0.81106503 -0.81107731 2.2896341 4 Now create each of the 5 test sets. set.seed(2352) ## first create the indices for the test sets nfolds &lt;- 5 test.groups &lt;- sample(1:nfolds, size=23, replace=TRUE) test.groups ## [1] 2 5 2 5 4 3 1 4 1 2 3 5 3 1 5 2 1 4 3 2 4 5 4 ## test.groups == k means that the observation will be in the kth test set ## For such a small dataset, you may want to randomly generate the ## test sets so that they all have the same size. Now, compute cross-validation estimates of the mean-squared error over a grid of \\(\\lambda\\) values lam.seq &lt;- seq(0, 200, by=5) MSE &lt;- matrix(0, nfolds, length(lam.seq)) for(j in 1:length(lam.seq)) { for(k in 1:nfolds) { soccer.test &lt;- soccer[test.groups==k,] soccer.train &lt;- soccer[test.groups!=k,] tmp.lm &lt;- glmmLasso(points ~ transfer.spendings + ave.unfair.score + ball.possession + tackles + ave.attend + sold.out, rnd = list(team=~1), lambda=lam.seq[j], data = soccer.train) predicted.values &lt;- predict(tmp.lm, newdata=soccer.test) MSE[k,j] &lt;- mean((predicted.values - soccer.test$points)^2) } } plot(lam.seq, colMeans(MSE), xlab=expression(lambda), ylab=&quot;MSE&quot;, main=&quot;5-fold cross-validation for the soccer data&quot;) lines(lam.seq, colMeans(MSE)) According to the cross-validation estimates of prediction error, the best value of \\(\\lambda\\) is roughly \\(80\\). 4.5 GLMM-Lasso with Binary Outcomes You can use glmmLasso with binary outcomes by adding the family=binomial() argument. As a quick example, let’s look at the ohio data from the geepack package. library(geepack) data(ohio) head(ohio) ## resp id age smoke ## 1 0 0 -2 0 ## 2 0 0 -1 0 ## 3 0 0 0 0 ## 4 0 0 1 0 ## 5 0 1 -2 0 ## 6 0 1 -1 0 For the glmmLasso function, you do need to make sure the “id variable” is a factor. ohio$id &lt;- factor(ohio$id) Let’s now fit a penalized generalized linear mixed model with \\(\\lambda = 10\\): ohio.fit10 &lt;- glmmLasso(smoke ~ resp + age, family=binomial(), rnd = list(id=~1), lambda=10, data = ohio) It looks like the wheeze status variable was selected while the age variable was not. summary(ohio.fit10) ## Call: ## glmmLasso(fix = smoke ~ resp + age, rnd = list(id = ~1), data = ohio, ## lambda = 10, family = binomial()) ## ## ## Fixed Effects: ## ## Coefficients: ## Estimate StdErr z.value p.value ## (Intercept) -1.03844 NA NA NA ## resp 0.10501 NA NA NA ## age 0.00000 NA NA NA ## ## Random Effects: ## ## StdDev: ## id ## id 2.674618 References "],
["risk-prediction.html", "Chapter 5 Risk Prediction and Validation (Part I) 5.1 Risk Prediction/Stratification 5.2 Area under the ROC curve and the C-statistic 5.3 Area under the ROC curve 5.4 Calibration 5.5 Longitudinal Data and Risk Score Validation", " Chapter 5 Risk Prediction and Validation (Part I) 5.1 Risk Prediction/Stratification For binary outcomes, a risk prediction is related to the predicted probability that an individual has or will develop a certain condition/trait. Examples of a risk prediction for a binary outcome: Probability that someone has hypertension. Probability that someone has type-2 diabetes. Probability someone will be hospitalized over the next 1 year. Risk stratification: Often, a risk prediction model will only report whether or not someone belongs to one of several risk strata. For example, high, medium, or low risk. 5.2 Area under the ROC curve and the C-statistic 5.2.1 Sensitivity and Specificity Let \\(g(\\mathbf{x}_{i})\\) be a risk score for an individual with covariate vector \\(\\mathbf{x}_{i}\\). Higher values of \\(g(\\mathbf{x}_{i})\\) are supposed to imply greater probability that the binary outcome \\(Y_{i}\\) is equal to \\(1\\). Though \\(g(\\mathbf{x}_{i})\\) does not necessarily have to be a predicted probability. The value \\(t\\) will be a threshold which determines whether or not, we predict \\(Y_{i} = 1\\) or not. \\(g(\\mathbf{x}_{i}) \\geq t\\) implies \\(Y_{i} = 1\\) \\(g(\\mathbf{x}_{i}) &lt; t\\) implies \\(Y_{i} = 0\\) The sensitivity of the risk score \\(g(\\mathbf{x}_{i})\\) with the threshold \\(t\\) is defined as the probability you “predict” \\(Y_{i} = 1\\) assuming that \\(Y_{i}\\) is, in fact, equal to \\(1\\). In other words, the sensitivity is the probability of making the right decision given that \\(Y_{i} = 1\\). Sensitivity is often called the “true positive rate”. The sensitivity is defined as: \\[\\begin{eqnarray} \\textrm{Sensitivity}(t; g) &amp;=&amp; P\\big\\{ g(\\mathbf{x}_{i}) \\geq t| Y_{i} = 1 \\big\\} \\nonumber \\\\ &amp;=&amp; \\frac{P\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 1 \\big\\}}{P\\big\\{ Y_{i} = 1 \\big\\} }\\nonumber \\\\ &amp;=&amp; \\frac{P\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 1 \\big\\}}{ P\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 1 \\big\\} + P\\big\\{ g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 1 \\big\\}} \\end{eqnarray}\\] For a worthless risk score that is totally uninformative about the outcome, we should expect the sensitivity to be close to \\(P\\{ g(\\mathbf{x}_{i}) \\geq t \\}\\). You can compute the in-sample sensitivity with \\[\\begin{eqnarray} \\hat{\\textrm{Sensitivity}}(t; g) &amp;=&amp; \\frac{\\sum_{i=1}^{n} I\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 1 \\big\\} }{ \\sum_{i=1}^{n} I\\big\\{g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 1 \\big\\} + \\sum_{i=1}^{n} I\\big\\{ g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 1 \\big\\}} \\nonumber \\\\ &amp;=&amp; \\frac{\\textrm{number of true positives}}{\\textrm{number of true positives} + \\textrm{number of false negatives} } \\end{eqnarray}\\] The specificity of the risk score \\(g(\\mathbf{x}_{i})\\) with the threshold \\(t\\) is defined as the probability you “predict” \\(Y_{i} = 0\\) assuming that \\(Y_{i}\\) is, in fact, equal to \\(0\\). The specificity is defined as: \\[\\begin{eqnarray} \\textrm{Specificity}(t; g) &amp;=&amp; P\\big\\{ g(\\mathbf{x}_{i}) &lt; t| Y_{i} = 0 \\big\\} \\nonumber \\\\ &amp;=&amp; \\frac{P\\big\\{ g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 0 \\big\\}}{ P\\big\\{ g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 0 \\big\\} + P\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 0 \\big\\}} \\end{eqnarray}\\] Note that \\(1 - \\textrm{Specificity}(t; g) = P\\big\\{ g(\\mathbf{x}_{i}) \\geq t| Y_{i} = 0 \\big\\}\\). \\(1 - \\textrm{Specificity}(t; g)\\) is often called the “false positive rate” You can compute the in-sample specificity with \\[\\begin{eqnarray} \\hat{\\textrm{Specificity}}(t; g) &amp;=&amp; \\frac{\\sum_{i=1}^{n} I\\big\\{ g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 0 \\big\\} }{ \\sum_{i=1}^{n} I\\big\\{g(\\mathbf{x}_{i}) &lt; t, Y_{i} = 0 \\big\\} + \\sum_{i=1}^{n} I\\big\\{ g(\\mathbf{x}_{i}) \\geq t, Y_{i} = 0 \\big\\}} \\nonumber \\\\ &amp;=&amp; \\frac{\\textrm{number of true negatives}}{\\textrm{number of true negatives} + \\textrm{number of false positives} } \\end{eqnarray}\\] For a worthless risk score that is totally uninformative about the outcome, we should expect the specificity to be close to \\(P\\{ g(\\mathbf{x}_{i}) &lt; t \\}\\). Note that high values of both sensitivity and specificity is good. For a “perfect” risk score, both sensitivity and specificity would be equal to \\(1\\). 5.2.2 The ROC curve The receiver operating characteristic (ROC) curve graphically depicts how sensitivity and specificity change as the threshold \\(t\\) varies. Let \\(t_{i} = g(\\mathbf{x}_{i})\\) and let \\(t_{(1)} &gt; t_{(2)} &gt; ... &gt; t_{(n)}\\) be the ordered values of \\(t_{1}, \\ldots, t_{n}\\). To construct an ROC curve we are going to plot sentivity vs. 1 - specificity for each of the thresholds \\(t_{(1)}, \\ldots, t_{(n)}\\). Let \\(x_{i} = 1 - \\hat{\\textrm{Specificity}}(t_{(i)}; g)\\) and \\(y_{i} = \\hat{\\textrm{Sensitivity}}(t_{(i)}; g)\\). We will define \\(x_{0} = y_{0} = 0\\) and \\(x_{n+1} = y_{n+1} = 1\\). \\(x_{0}\\), \\(y_{0}\\) represent 1 - specificity and sensitivity when using \\(t = \\infty\\). \\(x_{n+1}\\), \\(y_{n+1}\\) represent 1 - specificity and sensitivity when using \\(t = -\\infty\\). Plotting \\(y_{i}\\) vs. \\(x_{i}\\) for \\(i = 0, \\ldots, n+1\\) will give you the ROC curve. Ideally, the values of \\(y_{i}\\) will close to \\(1\\) for all \\(i\\). For a worthless risk score we should expect both \\(y_{i}\\) and \\(x_{i}\\) to be roughly equal to \\(P(g(\\mathbf{x}_{i}) \\geq t)\\). Hence, plotting \\(y_{i}\\) vs. \\(x_{i}\\) should be fairly close to the line \\(y=x\\). 5.2.3 Computing the ROC curve To try computing an ROC curve, we will use the Wisconsin Breast Cancer dataset which is available in the biopsy dataset from the MASS package. library(MASS) data(biopsy) head(biopsy) ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## 1 1000025 5 1 1 1 2 1 3 1 1 benign ## 2 1002945 5 4 4 5 7 10 3 2 1 benign ## 3 1015425 3 1 1 1 2 2 3 1 1 benign ## 4 1016277 6 8 8 1 3 4 3 7 1 benign ## 5 1017023 4 1 1 3 2 1 3 1 1 benign ## 6 1017122 8 10 10 8 7 10 9 7 1 malignant ## Look at number of &quot;benign&quot; and &quot;malignant&quot; tumors table(biopsy$class) ## ## benign malignant ## 458 241 biopsy$tumor.type &lt;- ifelse(biopsy$class==&quot;malignant&quot;, 1, 0) table(biopsy$tumor.type) ## ## 0 1 ## 458 241 Let’s compute risk scores for tumor malignancy by using a logistic regression model with class as the outcome and variables V1, V3, V4, V7, V8 as the covariates. Our risk score for the \\(i^{th}\\) case, will be the predicted probability of having a malignant tumor given the covariate information logreg.model &lt;- glm(tumor.type ~ V1 + V3 + V4 + V7 + V8, family=&quot;binomial&quot;, data=biopsy) risk.score &lt;- logreg.model$fitted.values Let’s now compute the sensitivity and specificity for a threshold of \\(t = 0.5\\) Sensitivity &lt;- function(thresh, Y, risk.score) { sum((risk.score &gt;= thresh)*Y)/sum(Y) } Specificity &lt;- function(thresh, Y, risk.score) { sum((risk.score &lt; thresh)*(1 - Y))/sum(1 - Y) } Sensitivity(0.5, Y=biopsy$tumor.type, risk.score) ## [1] 0.9502075 Specificity(0.5, Y=biopsy$tumor.type, risk.score) ## [1] 0.9759825 For the threshold of \\(t = 0.5\\), we have a sensitivity of about \\(0.95\\) and a specificity of about \\(0.975\\). Now, let’s compute the ROC curve by computing sensitivity and specificity for each risk score (plus the values of 0 and 1). sorted.riskscores &lt;- c(1, sort(risk.score, decreasing=TRUE), 0) mm &lt;- length(sorted.riskscores) roc.y &lt;- roc.x &lt;- rep(0, mm) for(k in 1:mm) { thresh.val &lt;- sorted.riskscores[k] roc.y[k] &lt;- Sensitivity(thresh.val, Y=biopsy$tumor.type, risk.score) roc.x[k] &lt;- 1 - Specificity(thresh.val, Y=biopsy$tumor.type, risk.score) } plot(roc.x, roc.y, main=&quot;ROC curve for biopsy data&quot;, xlab=&quot;1 - Specificity&quot;, ylab=&quot;Sensitivity&quot;, las=1) lines(roc.x, roc.y, type=&quot;s&quot;) abline(0, 1) Let’s compare the logistic regression ROC curve with a worthless risk score where we generate risk scores randomly from a uniform distribution. rr &lt;- runif(nrow(biopsy)) sorted.rr &lt;- c(1, sort(rr, decreasing=TRUE), 0) mm &lt;- length(sorted.rr) roc.random.y &lt;- roc.random.x &lt;- rep(0, mm) for(k in 1:mm) { thresh.val &lt;- sorted.rr[k] roc.random.y[k] &lt;- Sensitivity(thresh.val, Y=biopsy$tumor.type, rr) roc.random.x[k] &lt;- 1 - Specificity(thresh.val, Y=biopsy$tumor.type, rr) } plot(roc.random.x, roc.random.y, main=&quot;ROC curve for biopsy data&quot;, xlab=&quot;1 - Specificity&quot;, ylab=&quot;Sensitivity&quot;, las=1, col=&quot;red&quot;, type=&quot;n&quot;) lines(roc.random.x, roc.random.y, type=&quot;s&quot;, col=&quot;red&quot;) lines(roc.x, roc.y, type=&quot;s&quot;) legend(&quot;bottomright&quot;, legend=c(&quot;logistic regression risk scores&quot;, &quot;random risk scores&quot;), col=c(&quot;black&quot;, &quot;red&quot;), lwd=2, bty=&#39;n&#39;) abline(0, 1) 5.3 Area under the ROC curve The Area Under the ROC curve AUC is the area under the graph of the points \\((x_{i}, y_{i})\\), \\(i = 0, \\ldots, n+1\\). The AUC is given by \\[\\begin{equation} AUC = \\sum_{i=0}^{n} y_{i}(x_{i+1} - x_{i}) \\end{equation}\\] 5.3.1 Rewriting the formula for the AUC Note that \\[\\begin{equation} y_{i} = \\sum_{k=1}^{n} I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}\\} I\\{ Y_{k} = 1 \\}\\Big/\\sum_{k=1}^{n} I\\{ Y_{k} = 1\\} = \\frac{1}{n\\hat{p}}\\sum_{k=1}^{n} a_{ki}, \\end{equation}\\] where \\(n\\hat{p} = \\sum_{k=1}^{n} I\\{ Y_{k} = 1\\}\\) and \\(a_{ki} = I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}\\} I\\{ Y_{k} = 1 \\}\\). Because \\(t_{(i)} \\geq t_{(i+1)}\\): \\[\\begin{eqnarray} x_{i+1} - x_{i} &amp;=&amp; \\sum_{k=1}^{n} \\Big(I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i+1)}, Y_{k} = 0 \\} - I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}, Y_{k} = 0 \\}\\Big)\\Big/\\sum_{k=1}^{n} I\\{ Y_{k} = 0\\} \\nonumber \\\\ &amp;=&amp; \\frac{1}{n(1 - \\hat{p})}\\sum_{k=1}^{n} I\\{g(\\mathbf{x}_{k}) &lt; t_{(i)}\\} I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i+1)}\\} I\\{Y_{k} = 0 \\} \\\\ &amp;=&amp; \\frac{1}{n(1 - \\hat{p})}\\sum_{k=1}^{n} I\\{ g(\\mathbf{x}_{k}) = t_{(i+1)}\\} I\\{Y_{k} = 0 \\} \\nonumber \\\\ &amp;=&amp; \\frac{1}{n(1 - \\hat{p})}\\sum_{k=1}^{n} b_{ki} \\end{eqnarray}\\] where \\(n(1 - \\hat{p}) = \\sum_{k=1}^{n} I\\{ Y_{k} = 0\\}\\) and \\(b_{ki} = I\\{ g(\\mathbf{x}_{k}) = t_{(i+1)}\\} I\\{Y_{k} = 0 \\}\\). So, we can express the AUC as: \\[\\begin{eqnarray} AUC &amp;=&amp; \\frac{1}{n^{2}\\hat{p}(1 - \\hat{p})}\\sum_{i=0}^{n} \\sum_{k=0}^{n} a_{ki} \\sum_{k=0}^{n} b_{ki} = \\frac{1}{n^{2}\\hat{p}(1 - \\hat{p})} \\sum_{k=0}^{n} \\sum_{j=0}^{n}\\sum_{i=0}^{n} a_{ki} b_{ji} \\\\ &amp;=&amp; \\frac{1}{n^{2}\\hat{p}(1 - \\hat{p})} \\sum_{k=0}^{n} \\sum_{j=0}^{n} I\\{ Y_{k} = 1 \\} I\\{Y_{j} = 0 \\} \\sum_{i=0}^{n} I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}\\}I\\{ g(\\mathbf{x}_{j}) = t_{(i+1)}\\} \\tag{5.1} \\end{eqnarray}\\] Note now that because the \\(t_{(i)}\\) are the ordered values of the \\(g(\\mathbf{x}_{h})\\) \\[\\begin{equation} \\sum_{i=0}^{n} I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}\\}I\\{ g(\\mathbf{x}_{j}) = t_{(i+1)}\\} = I\\{ g(\\mathbf{x}_{k}) \\geq t_{(j^{*} - 1)}\\} = I\\{ g(\\mathbf{x}_{k}) &gt; t_{(j^{*})}\\}, \\end{equation}\\] where \\(j^{*}\\) is the index such that \\(t_{(j^{*})} = g(\\mathbf{x}_{j})\\). Hence, \\[\\begin{equation} \\sum_{i=0}^{n} I\\{ g(\\mathbf{x}_{k}) \\geq t_{(i)}\\}I\\{ g(\\mathbf{x}_{j}) = t_{(i+1)}\\} = I\\{ g(\\mathbf{x}_{k}) &gt; g(\\mathbf{x}_{j}) \\} \\tag{5.2} \\end{equation}\\] Now, by plugging (5.2) into (5.1), we can finally express the AUC as \\[\\begin{eqnarray} AUC &amp;=&amp; \\frac{1}{n^{2}\\hat{p}(1 - \\hat{p})} \\sum_{k=0}^{n} \\sum_{j=0}^{n} I\\{ g(\\mathbf{x}_{k}) &gt; g(\\mathbf{x}_{j}) \\}I\\{ Y_{k} = 1 \\} I\\{Y_{j} = 0 \\} \\end{eqnarray}\\] 5.3.2 Interpreting the AUC We can write the AUC as \\[\\begin{equation} \\textrm{AUC} = S_{1}/S_{2} \\end{equation}\\] The sum \\(S_{2}\\) counts the number of all discordant pairs of responses The pair of outcomes \\((Y_{k}, Y_{j})\\) is discordant if \\(Y_{k} = 1\\) and \\(Y_{j}=0\\) or vice versa. \\[\\begin{equation} S_{2} = \\sum_{i=1}^{n}I\\{ Y_{i} = 0\\}\\sum_{i=1}^{n} I\\{Y_{i} = 1\\} = \\sum_{j=1}^{n}\\sum_{k=1}^{n} I\\{ Y_{j} = 0\\} I\\{Y_{k} = 1\\} \\end{equation}\\] Now, look at the sum \\(S_{1}\\): \\[\\begin{eqnarray} S_{1} &amp;=&amp; \\sum_{k=0}^{n} \\sum_{j=0}^{n} I\\{ g(\\mathbf{x}_{k}) &gt; g(\\mathbf{x}_{j}) \\}I\\{ Y_{k} = 1 \\} I\\{Y_{j} = 0 \\} \\end{eqnarray}\\] \\(S_{1}\\) looks at all discordant pairs of responses and counts the number of pairs where the risk score ordering agrees with the ordering of the responses. To summarize: The AUC is the proportion of discordant outcome pairs where the risk score ordering for that pair agrees with the ordering of the outcomes An AUC of \\(0.5\\) means that the risk score is performing about the same as a risk score generated at random. The AUC is often referred to as the concordance index, or c-index. Let’s compute the AUC for our logistic regression-based risk score for the biopsy data: AUC.biopsy &lt;- sum(roc.y[-length(roc.y)]*diff(roc.x)) round(AUC.biopsy, 4) ## [1] 0.9928 This is a very high AUC: \\(0.9928\\) 5.3.3 Computing the AUC in R You can compute the AUC in R without writing all your own functions by using the pROC package. With the pROC package, you start by inputting your binary outcomes and risk scores into the roc function in order to get an “roc object”. library(pROC) roc.biopsy &lt;- roc(biopsy$tumor.type, risk.score) To find the AUC, you can then use auc(roc.biopsy) auc( roc.biopsy ) ## Area under the curve: 0.9928 You can plot the ROC curve by just plugging in the roc object into the plot function. plot(roc.biopsy) To also print the AUC value, you can just add print.auc=TRUE plot(roc.biopsy, print.auc=TRUE) 5.4 Calibration The AUC, or c-index is a measure of the statistical discrimination of the risk score. However, a high value of the AUC does not imply that the risk score is well-calibrated. Calibration refers to the agreement between observed frequency of the outcome and the fitted probabilities of those outcomes. For example, if we look at a group of individuals all of whom have a fitted probability of \\(0.2\\), then we should expect that roughly \\(20\\%\\) of the outcomes should equal \\(1\\) from this group. We can examine this graphically by looking at the observed proportion of successes vs. the fitted probabilities for several risk strata. Specifically, if we have risk score-cutoffs \\(r_{1}, \\ldots, r_{G}\\), the observed proportion of successes in the \\(k^{th}\\) risk stratum is \\[\\begin{equation} O_{k} = \\frac{1}{n}\\sum_{i=1}^{n} Y_{i}I\\{ r_{k-1} &lt; g(\\mathbf{x}_{i}) \\leq r_{k} \\} \\end{equation}\\] The expected proportion of successes in the \\(k^{th}\\) risk stratum is \\[\\begin{equation} P_{k} = \\frac{1}{n}\\sum_{i=1}^{n} g(\\mathbf{x}_{i})I\\{ r_{k-1} &lt; g(\\mathbf{x}_{i}) \\leq r_{k} \\} \\end{equation}\\] If \\(g(\\mathbf{x}_{i})\\) is well-calibrated, \\(O_{k}\\) and \\(P_{k}\\) should be fairly similar for each \\(k\\). Let’s make a calibration plot for the biopsy data. First, let’s make 10 risk strata using the quantiles of our logistic regression-based risk score. rr &lt;- c(0, quantile(risk.score, prob=seq(0.1, 0.9, by=0.1)), 1) rr ## 10% 20% 30% 40% 50% ## 0.000000000 0.001505966 0.002756161 0.005385182 0.010154320 0.019231612 ## 60% 70% 80% 90% ## 0.074574998 0.841857858 0.989561027 0.999471042 1.000000000 Now, compute observed and expected frequencies for each of the risk strata and plot the result: observed.freq &lt;- pred.freq &lt;- rep(0, 10) for(k in 2:11) { ind &lt;- risk.score &lt;= rr[k] &amp; risk.score &gt; rr[k-1] # stratum indicators observed.freq[k] &lt;- mean(biopsy$tumor.type[ind]) pred.freq[k] &lt;- mean(risk.score[ind]) } plot(observed.freq, pred.freq, xlab=&quot;Observed Frequency&quot;, ylab = &quot;Predicted Frequency&quot;, las=1, main=&quot;Calibration plot for biopsy data&quot;) lines(observed.freq, pred.freq) abline(0, 1, lty=2) Most of the risk scores are more concentrated near zero, but this calibration plot shows fairly good calibration. Expected vs. Observed frequencies are mostly close to the \\(y = x\\) straight line. Sometimes an estimated intercept and slope from a regression of expected vs. observed frequencies is reported. We should expect that the intercept should be close to \\(0\\) and the slope should be close to \\(1\\) for a well-calibrated risk score. lm(pred.freq ~ observed.freq) ## ## Call: ## lm(formula = pred.freq ~ observed.freq) ## ## Coefficients: ## (Intercept) observed.freq ## 0.001759 0.994948 The Hosmer–Lemeshow test is a more formal test that compares these types of observed vs. expected frequencies. 5.5 Longitudinal Data and Risk Score Validation When you have longitudinal responses \\(Y_{ij}\\), sensitivity, specificity, and the AUC/c-index will depend on what exactly you are trying to predict. If you are trying to predict \\(Y_{ij} = 1\\) vs. \\(Y_{ij} = 0\\) for each \\(j\\), sensitivity and specificity will be defined by \\[\\begin{equation} P\\{ g(\\mathbf{x}_{ij}) \\geq t|Y_{ij} = 1\\} \\qquad \\textrm{ and } \\qquad P\\{ g(\\mathbf{x}_{ij}) &lt; t|Y_{ij} = 0\\} \\end{equation}\\] Here, \\(g(\\mathbf{x}_{ij})\\) would be a risk score based on covariate information up to and including time \\(t_{ij}\\) and could include responses before time \\(t_{ij}\\). In this case, the AUC would be calculated in the same way as the non-longitudinal case - you would just sum over all responses and risk scores across all individuals and time points. In other cases, you may want to predict a single outcome \\(\\tilde{Y}_{i}\\) even though the covariates are collected longitudinally over additional time points. For example, \\(\\tilde{Y}_{i}\\) might be an indicator of whether or not a patient is hypertensive over a particular time window. In this case, you might compute a single risk score \\(\\hat{g}_{i}\\) for each individual. For example, \\(\\hat{g}_{i} = \\frac{1}{n_{i}}\\sum_{j=1}^{n_{i}} g(\\mathbf{x}_{ij})\\). For example, \\(\\hat{g}_{i} = \\textrm{median} \\{ g(\\mathbf{x}_{i1}), \\ldots, g(\\mathbf{x}_{in_{i}}) \\}\\). For example, \\(\\hat{g}_{i} = \\max\\{ g(\\mathbf{x}_{i1}), \\ldots, g(\\mathbf{x}_{in_{i}}) \\}\\). To “validate” a risk score, you generally want to look at out-of-sample performance of the risk score. For example, you might build your risk model using data from a specific six-month time window and look at the AUC statistic for outcomes in a later six-month time window. The risk score in the later time window would be constructed only using covariate information. Looking at the out-of-sample performance over a different time window or using data from a different source is often a good way of justifying the robustness/generalizability of a particular risk model. "],
["risk-prediction2.html", "Chapter 6 Risk Prediction and Validation (Part II) 6.1 The Brier Score 6.2 Brier Scores with Longitudinal Data", " Chapter 6 Risk Prediction and Validation (Part II) 6.1 The Brier Score Binary outcomes - \\(Y_{i}\\) for individual \\(i\\). Let \\(g(\\mathbf{x}_{i})\\) be a risk score for an individual with covariate vector \\(\\mathbf{x}_{i}\\). If \\(g(\\mathbf{x}_{i})\\) is interpreted as an estimate of the probability that \\(Y_{i} = 1\\), the Brier score is a measure of the predictive accuracy of \\(g(\\mathbf{x}_{i})\\). For binary outcomes \\(Y_{i}\\) and risk scores \\(g(\\mathbf{x}_{i})\\), the Brier score is defined as \\[\\begin{equation} BS(Y, g) = \\frac{1}{n}\\sum_{i=1}^{n} \\{ Y_{i} - g(\\mathbf{x}_{i}) \\}^{2} \\end{equation}\\] The Brier score is typically used to compare the accuracy of risk scores. It is hard to tell if a risk score is good just by looking at the Brier score itself without comparing it with other methods. Even if \\(g(\\mathbf{x}_{i})\\) is a class prediction rather than a probability (i.e., \\(g(\\mathbf{x}_{i}) = 0\\) or \\(g(\\mathbf{x}_{i}) = 1\\)), the Brier score can be interpreted as the proportion of “misclassified” outcomes \\[\\begin{equation} BS(Y, g) = \\frac{1}{n}\\sum_{i=1}^{n} \\{ Y_{i} - g(\\mathbf{x}_{i}) \\}^{2} = \\frac{1}{n} \\sum_{i=1}^{n} I\\{Y_{i} \\neq g(\\mathbf{x}_{i}) \\} \\end{equation}\\] The Brier score is a single measure that is affected by both the discrimination and calibration of the risk score. The usual justification for this is to look at the following approximation of the Brier score \\[\\begin{equation} BS(Y, g) \\approx \\tilde{BS}(Y,g) = \\frac{1}{n}\\sum_{s=1}^{S} \\sum_{i=1}^{n} a_{is}\\{Y_{i} - \\bar{g}_{s} \\}^{2} \\end{equation}\\] This approximation assumes \\(S\\) strata: \\([s_{0}, s_{1}), [s_{1}, s_{2}), \\ldots, [s_{S-1}, s_{S})\\). \\(a_{is}\\) is an indicator of whether or not the \\(i^{th}\\) observation falls into the \\(s^{th}\\) stratum: That is, \\(a_{is} = 1\\) if \\(s_{s-1} \\leq g(\\mathbf{x}_{i}) &lt; s_{s}\\) \\(\\bar{g}_{s}\\) is the average value of the risk score within stratum \\(s\\) \\[\\begin{equation} \\bar{g}_{s} = \\frac{1}{n_{s}} \\sum_{i=1}^{n} a_{is} g(\\mathbf{x}_{i}) \\end{equation}\\] and \\(n_{s}\\) is the number of observation where the risk score is in stratum \\(s\\). If we let \\(\\bar{Y}_{s} = \\frac{1}{n_{s}}\\sum_{i=1}^{n} a_{is}Y_{i}\\) be the proportion of 1’s in stratum \\(s\\), we can simplify the expression for the approximate Brier score as follows: \\[\\begin{eqnarray} \\tilde{BS}(Y,g) &amp;=&amp; \\frac{1}{n}\\sum_{s=1}^{S} \\sum_{i=1}^{n} a_{is}\\{Y_{i} - \\bar{Y}_{s} + \\bar{Y}_{s} - \\bar{g}_{s} \\}^{2} \\nonumber \\\\ &amp;=&amp; \\frac{1}{n}\\sum_{s=1}^{S} \\sum_{i=1}^{n} a_{is}\\{Y_{i} - \\bar{Y}_{s} \\}^{2} + \\frac{1}{n}\\sum_{s=1}^{S} n_{s}\\{\\bar{Y}_{s} - \\bar{g}_{s} \\}^{2} \\nonumber \\\\ &amp;=&amp; \\frac{1}{n}\\sum_{s=1}^{S} n_{s}\\bar{Y}_{s}(1 - \\bar{Y}_{s}) + \\frac{1}{n}\\sum_{s=1}^{S} n_{s}\\{\\bar{Y}_{s} - \\bar{g}_{s} \\}^{2} \\nonumber \\\\ &amp;=&amp; B_{D} + B_{C} \\end{eqnarray}\\] The quantity \\(B_{D} = \\frac{1}{n}\\sum_{s=1}^{S} n_{s}\\bar{Y}_{s}(1 - \\bar{Y}_{s})\\) is related to the discrimination of the risk score \\(g\\). To get a sense of why \\(B_{D}\\) measures discrimination, suppose \\(s\\) is a stratum where \\(s_{s} \\leq t\\). If the risk score has good discrimination, this threshold should separate most of the “successes” from the “failures”. That is most with \\(g(\\mathbf{x}_{i}) \\leq t\\) has \\(Y_{i} = 0\\) and most with \\(g(\\mathbf{x}_{i}) &gt; t\\) has \\(Y_{i}=1\\). This \\(\\bar{Y}_{s}(1 - \\bar{Y}_{s})\\) is close to \\(0\\). If this is close to \\(0\\) for most threholds, \\(B_{D}\\) will be small. The quantity \\(B_{C} = \\frac{1}{n}\\sum_{s=1}^{S} n_{s}\\{\\bar{Y}_{s} - \\bar{g}_{s} \\}^{2}\\) is a measure of calibration. For a well-calibrated risk score, the proportion of successes \\(\\bar{Y}_{s}\\) in stratum \\(s\\) should be close to the average value of the risk score \\(g_{s}\\) in stratum \\(s\\). 6.1.1 Brier scores for biopsy data Let’s compute the Brier score using the biopsy data again from the MASS package. library(rpart) library(MASS) data(biopsy) # Create binary outcome for tumor class biopsy$tumor.type &lt;- ifelse(biopsy$class==&quot;malignant&quot;, 1, 0) head(biopsy) ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class tumor.type ## 1 1000025 5 1 1 1 2 1 3 1 1 benign 0 ## 2 1002945 5 4 4 5 7 10 3 2 1 benign 0 ## 3 1015425 3 1 1 1 2 2 3 1 1 benign 0 ## 4 1016277 6 8 8 1 3 4 3 7 1 benign 0 ## 5 1017023 4 1 1 3 2 1 3 1 1 benign 0 ## 6 1017122 8 10 10 8 7 10 9 7 1 malignant 1 Let’s try constructing fitted probabilities using three approaches: logistic regression CART random forest library(rpart) library(randomForest) # Fit CART, logistic regression, and random forest cart.model &lt;- rpart(class ~ V1 + V3 + V4 + V7 + V8, data=biopsy) logreg.model &lt;- glm(tumor.type ~ V1 + V3 + V4 + V7 + V8, family=&quot;binomial&quot;, data=biopsy) RF.model &lt;- randomForest(class ~ V1 + V3 + V4 + V7 + V8, data=biopsy, ntree = 500) Let’s then compute “risk scores” from each method. probs.cart &lt;- predict(cart.model) head(probs.cart) ## benign malignant ## 1 0.9837587 0.0162413 ## 2 0.0952381 0.9047619 ## 3 0.9837587 0.0162413 ## 4 0.0952381 0.9047619 ## 5 0.9837587 0.0162413 ## 6 0.0952381 0.9047619 # We want the second column of this matrix for the CART fitted probabilities risk.cart &lt;- probs.cart[,2] # logistic regression risk.logreg &lt;- predict(logreg.model, newdata=biopsy, type=&quot;response&quot;) # random forest risk scores risk.RF &lt;- predict(RF.model, newdata=biopsy, type = &quot;prob&quot;)[,2] The in-sample Brier scores for each method are: “In-sample” here meaning we are computing the Brier score using the same outcomes we used to construct the risk scores. brier.cart &lt;- mean((risk.cart - biopsy$tumor.type)^2) brier.logreg &lt;- mean((risk.logreg - biopsy$tumor.type)^2) brier.RF &lt;- mean((risk.RF - biopsy$tumor.type)^2) round(c(brier.cart, brier.logreg, brier.RF), 4) ## [1] 0.0450 0.0280 0.0057 When comparing in-sample Brier scores, CART is the worst, logistic regression is in the middle, and random forest is the best. Figure 6.1: Fitted CART model for the biopsy data 6.1.2 Out-of-sample comparisons Looking at out-of-sample performance is a better way to validate our risk scores. Let’s try a validation exercise by “training” our models on the first \\(400\\) observations of biopsy and then testing relative performance on the remaining observations. # Create train/test splits for biopsy data biopsy.train &lt;- biopsy[1:400,] biopsy.test &lt;- biopsy[401:699,] # Now, use each type of method on this training data cart.model.train &lt;- rpart(class ~ V1 + V3 + V4 + V7 + V8, data=biopsy.train) logreg.model.train &lt;- glm(tumor.type ~ V1 + V3 + V4 + V7 + V8, family=&quot;binomial&quot;, data=biopsy.train) RF.model.train &lt;- randomForest(class ~ V1 + V3 + V4 + V7 + V8, data=biopsy.train, ntree = 500) Using these models built on the training data, get the fitted probabilities for the test data risk.cart.test &lt;- predict(cart.model.train, newdata=biopsy.test)[,2] risk.logreg.test &lt;- predict(logreg.model.train, newdata=biopsy.test, type=&quot;response&quot;) risk.RF.test &lt;- predict(RF.model.train, newdata=biopsy.test, type = &quot;prob&quot;)[,2] Now, using these fitted probabilities on the test data, compute the Brier scores: brier.cart.test &lt;- mean((risk.cart.test - biopsy.test$tumor.type)^2) brier.logreg.test &lt;- mean((risk.logreg.test - biopsy.test$tumor.type)^2) brier.RF.test &lt;- mean((risk.RF.test - biopsy.test$tumor.type)^2) round(c(brier.cart.test, brier.logreg.test, brier.RF.test), 4) ## [1] 0.0359 0.0135 0.0191 For the out-of-sample Brier score, both logistic regression and random forest are notably better than CART. Logistic regression is actually slightly better than random forest in out of sample performance with random forest (at least for this particular train/test split). 6.2 Brier Scores with Longitudinal Data Let’s revisit the ohio data again from the geepack package library(geepack) data(ohio) head(ohio, 10) ## resp id age smoke ## 1 0 0 -2 0 ## 2 0 0 -1 0 ## 3 0 0 0 0 ## 4 0 0 1 0 ## 5 0 1 -2 0 ## 6 0 1 -1 0 ## 7 0 1 0 0 ## 8 0 1 1 0 ## 9 0 2 -2 0 ## 10 0 2 -1 0 Each individual has 4 follow-up visits. The variable resp is the wheezing status of the individual at each follow up. The variable smoke is a baseline variable that does not change over time. This is an indicator of maternal smoking. age is a time-varying covariate. 6.2.1 Option 1 If we want to build a risk score for wheezing, evaluating the performance of this risk score will depend on exactly what we are trying to predict. Option 1: We want to predict whether or not some someone is diagnosed with wheezing over some time window, and we do not want to predict wheezing status at each time point. As an example of this, let’s build a risk score which: Only uses smoke as a covariate. Builds the risk score from the first two follow-up times. Let’s first construct a dataset called atleastone1 that records whether or not an individual had at least one positive wheezing status over the first two visits: atleastone2 will record whether or not an individual has at least one positive wheezing status over the last two visits. data(ohio) baseline.ohio &lt;- subset(ohio, age== -1) # data from baseline visit firsttwo.ohio &lt;- subset(ohio, age== -1 | age == 0) # data from visits 1-2 lasttwo.ohio &lt;- subset(ohio, age==1 | age==2) # data from visits 3-4 tmp &lt;- aggregate(firsttwo.ohio$resp, by=list(id=firsttwo.ohio$id), FUN=max) tmp2 &lt;- aggregate(lasttwo.ohio$resp, by=list(id=lasttwo.ohio$id), FUN=max) atleastone1 &lt;- merge(tmp, baseline.ohio, by=&quot;id&quot;) atleastone2 &lt;- merge(tmp2, baseline.ohio, by=&quot;id&quot;) head(atleastone1) ## id x resp age smoke ## 1 0 0 0 -1 0 ## 2 1 0 0 -1 0 ## 3 2 0 0 -1 0 ## 4 3 0 0 -1 0 ## 5 4 0 0 -1 0 ## 6 5 0 0 -1 0 table(atleastone1$resp) ## ## 0 1 ## 446 91 Let’s now build a risk score using only variable smoke as a covariate and a random choice of \\(300\\) observations set.seed(1234) train.ind &lt;- sample(1:537, size=300) atleastone1.train &lt;- atleastone1[train.ind,] mod1 &lt;- glm(resp ~ smoke, family=&quot;binomial&quot;, data=atleastone1.train) summary(mod1) ## ## Call: ## glm(formula = resp ~ smoke, family = &quot;binomial&quot;, data = atleastone1.train) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.5978 -0.5978 -0.5537 -0.5537 1.9754 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.7979 0.2078 -8.653 &lt;2e-16 *** ## smoke 0.1665 0.3311 0.503 0.615 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 253.63 on 299 degrees of freedom ## Residual deviance: 253.37 on 298 degrees of freedom ## AIC: 257.37 ## ## Number of Fisher Scoring iterations: 4 The risk scores for the hold-out individuals for the later follow-up times are given by risk1 &lt;- predict(mod1, newdata=atleastone2[-train.ind,], type=&quot;response&quot;) Now, let’s look at the Brier score on the remaining individuals in the atleast2 data set. mean((risk1 - atleastone2[-train.ind,]$resp)^2) ## [1] 0.1574466 An AUC probably does not make much sense here since there are only two possible values of the risk score. For calibration, we can just compare the predicted risk scores and the mean number of successes in each of the smoking categories in the hold-out sample: table(risk1) ## risk1 ## 0.142105263157904 0.163636363636364 ## 160 77 table(atleastone2[-train.ind,]$resp, atleastone2[-train.ind,]$smoke) ## ## 0 1 ## 0 135 56 ## 1 25 21 # Compare risk scores with 25/(25 + 135) ## [1] 0.15625 21/(21 + 56) ## [1] 0.2727273 This risk score does not seem all that well-calibrated for later time points. The overall prevalence of wheezing is a little bit higher in the hold-out sample. There is a larger difference between the smoking and non-smoking groups in the hold-out sample. 6.2.2 Option 2 As another option, you may want to predict outcomes for each time point in the hold-out dataset. In this case, I would probably just compute a Brier score by just averaging over all time points. For example, with a GEE, you might do the following: ind &lt;- c(1:400, 801:1200, 1601:2000) ## index of training set ohio.train &lt;- subset(ohio[ind,], age==-1 | age == 0) ohio.test &lt;- subset(ohio[-ind,], age==1 | age==2) fit.ex &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio.train, family=binomial, corstr=&quot;exch&quot;) rs2 &lt;- predict(fit.ex, newdata=ohio.test, type=&quot;response&quot;) ## Now, find Brier score that the takes average across all individuals and time points mean((rs2 - ohio.test$resp)^2) ## [1] 0.1270949 "]
]
